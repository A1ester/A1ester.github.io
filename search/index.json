[{"content":" [0xC40 , 0xE00) 97 [0xE00 , 0x1000) 98 [0x1000 , 0x1200) 99 [0x1200 , 0x1400) 100 [0x1400 , 0x1600) 101 等差 0x200 … [0x2800 , 0x2A00) 111 [0x2A00 , 0x3000) 112 [0x3000 , 0x4000) 113 [0x4000 , 0x5000) 114 等差 0x1000 … [0x9000 , 0xA000) 119 [0xA000 , 0x10000) 120 [0x10000 , 0x18000) 121 [0x18000 , 0x20000) 122 [0x20000 , 0x28000) 123 [0x28000 , 0x40000) 124 [0x40000 , 0x80000) 125 [0x80000 , …. ) 126\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 5.`tcache`： (1) 单链表，`LIFO`（后进先出），每个`bin`内存放的堆块大小相同，且最多存放`7`个，大小从`24 ~ 1032`个字节，用于存放`non-large`的`chunk`。 (2) `tcache_perthread_struct`本身也是一个堆块，大小为`0x250`，位于堆开头的位置，包含数组`counts`存放每个`bin`中的`chunk`当前数量，以及数组`entries`存放`64`个`bin`的首地址（可以通过**劫持此堆块**进行攻击）。 (3) 在释放堆块时，在放入`fast bin`之前，若`tcache`中对应的`bin`未满，则先放入`tcache`中。 (4) 从`fast bin`返回了一个`chunk`，则单链表中剩下的堆块会被放入对应的`tcache bin`中，直到上限。 从`small bin`返回了一个`chunk`，则双链表中剩下的堆块会被放入对应的`tcache bin`中，直到上限。 在将剩余堆块从`small bin`放入`tcache bin`的过程中，除了检测了第一个堆块的`fd`指针，都缺失了`__glibc_unlikely (bck-\u0026gt;fd != victim)`的双向链表完整性检测。 (5) `binning code`，如在遍历`unsorted bin`时，每一个符合要求的`chunk`都会优先被放入`tcache`，然后继续遍历，除非`tcache`已经装满，则直接返回，不然就在遍历结束后，若找到了符合要求的大小，则把`tcache`中对应大小的返回一个。 (6) 在`__libc_malloc()`调用`__int_malloc()`之前，如果`tcache bin`中有符合要求的`chunk`就直接将其返回。 (7) `CVE-2017-17426`是`libc-2.26`存在的漏洞，`libc-2.27`已经修复。 (8) 可将`tcache_count`整型溢出为`0xff`以绕过`tcache`，直接放入`unsorted bin`等，但在`libc-2.28`中，检测了`counts`溢出变成负数（`0x00-1=0xff`）的情况，且增加了对`double free`的检查。 (9) `calloc()`越过`tcache`取`chunk`，通过`calloc()`分配的堆块会**清零**。**补充：**`realloc()`的特殊用法：`size == 0`时，等同于`free`；`realloc_ptr == 0 \u0026amp;\u0026amp; size \u0026gt; 0` 时等同于`malloc`。如果当前连续内存块足够`realloc`的话，只是将`p`所指向的空间扩大，并返回`p`的指针地址；如果当前连续内存块不够，则再找一个足够大的地方，分配一块新的内存`q`，并将`p`指向的内容`copy`到`q`，返回 `q`。并将`p`所指向的内存空间`free`；若是通过`realloc`缩小堆块，则返回的指针`p`不变，但原先相比缩小后多余的那部分将会被`free`掉。 6.`top chunk`： 除了`house of force`外，其实对于`top chunk`还有一些利用点。 当申请的`size`不大于`mmap`的阈值，但`top chunk`当前的大小又不足以分配，则会扩展`top chunk`，然后从新`top chunk`里进行分配。 这里的扩展`top chunk`，其实不一定会直接扩展原先的`top chunk`，可能会先将原先的`top chunk`给`free`掉，再在之后开辟一段新区域作为新的`top chunk`。 具体是，如果`brk`等于该不够大小的`top chunk`（被记作`old_top_chunk`）的`end`位置（`old_end`，等于`old_top + old_size`），即`top chunk`的`size`并没有被修改，完全是自然地分配堆块，导致了`top chunk`不够用，则会从`old_top`处开辟更大的一块空间作为新的`top chunk`，也就是将原先的`old_top_chunk`进行扩展了，此时没有`free`，且`top chunk`的起始位置也没有改变，但是如果`brk`不等于`old_end`，则会先`free`掉`old_top_chunk`，再从`brk`处开辟一片空间作为`new_top_chunk`，此时的`top chunk`头部位置变为了原先的`brk`，而如今的`brk`也做了相应的扩展，并且`unsorted bin`或`tcache`中（一般修改的大小都至少会是`small bin`范围，但具体在哪得分情况看）会有被`free`的`old_top_chunk`。 因此，可以通过改小`top chunk`的`size`，再申请大堆块，做到对旧`top chunk`的`free`，不过修改的`size`需要绕过一些检测。 相关源码如下： ```C old_top = av-\u0026gt;top; old_size = chunksize (old_top); old_end = (char *) (chunk_at_offset (old_top, old_size)); // old_end = old_top + old_size assert ((old_top == initial_top (av) \u0026amp;\u0026amp; old_size == 0) || ((unsigned long) (old_size) \u0026gt;= MINSIZE \u0026amp;\u0026amp; prev_inuse (old_top) \u0026amp;\u0026amp; ((unsigned long) old_end \u0026amp; (pagesize - 1)) == 0)); 需要绕过以上的断言，主要就是要求被修改的top chunk的size的prev_inuse位要为1并且old_end要内存页对齐，所以就要求被修改的size的后三位和原先要保持一致。\nUse-After-Free (UAF) free(p)后未将p清零，若是没有其他检查的话，可能造成UAF漏洞。 double free就是利用UAF漏洞的经典例子。\n1.fast bin的double free：\n(1) fast bin对double free有检查，会检查当前的chunk是否与fast bin顶部的chunk相同，如果相同则报错并退出。因此，我们不能连续释放两次相同的chunk。 可采用如下方式在中间添加一个chunk便绕过检查： 释放A，单链表为A，再释放B，单链表为B-\u0026gt;A，再释放A，单链表为A-\u0026gt;B-\u0026gt;A，然后申请到A，同时将其中内容改成任意地址（改的是fd指针），单链表就成了B-\u0026gt;A-\u0026gt;X，其中X就是任意地址，这样再依次申请B，A后，再申请一次就拿到了地址X，可以在地址X中任意读写内容。 (2) 其实，若是有Edit功能的话，可以有如下方式： 若当前单链表是B-\u0026gt;A，将B的fd指针通过Edit修改为任意地址X，单链表就变成了B-\u0026gt;X，申请了B之后，再申请一次，就拿到了X地址，从而进行读写。 需要注意的是，以上的X准确说是fake chunk的chunk header地址，因为fast bin会检测chunk_header_addr + 8（即size）是否符合当前bin的大小。\n2.tcache的double free：\nlibc-2.28之前并不会检测double free，因此可以连续两次释放同一个堆块进入tcache，并且tcache的next指针指向的是user data，因此不会做大小的检测。 释放A，单链表为A，再释放A，单链表为A-\u0026gt;A，申请A并把其中内容（next指针）改成X，则单链表为A-\u0026gt;X，再申请两次，拿到X地址的读写权。 在以上过程结束后，实际上是放进tcache了两次，而申请取出了三次，因此当前tcache的counts会变成0xff，整型溢出，这是一个可以利用的操作，当然若是想避免此情况，在第一次释放A之前，可以先释放一次B，将其放入此tcache bin即可。 此外，若是有Edit功能，仿照上述 fast bin对应操作的技术被称为tcache_poisoning。\n3.glibc2.31下的double free：\n在 glibc2.29之后加入了对tcache二次释放的检查，方法是在tcache_entry结构体中加入了一个标志key，用于表示chunk是否已经在所属的tcache bin中，对于每个chunk而言，key在其bk指针的位置上。 当chunk被放入tcache bin时会设置key指向其所属的tcache结构体：e-\u0026gt;key = tcache;，并在free时，进入tcache bin之前，会进行检查：如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来；如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free。这是一个较为优秀的算法，进行了剪枝，具体源码如下：\n1 2 3 4 5 6 7 8 if (__glibc_unlikely(e-\u0026gt;key == tcache)) { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-\u0026gt;entries[tc_idx]; tmp; tmp = tmp-\u0026gt;next) if (tmp == e) malloc_printerr(\u0026#34;free(): double free detected in tcache 2\u0026#34;); } 可通过fast bin double free+tcache stash机制来进行绕过： (1) 假设目前tcache被填满了：C6-\u0026gt;C5-\u0026gt;C4-\u0026gt;C3-\u0026gt;C2-\u0026gt;C1-\u0026gt;C0，fast bin中为：C7-\u0026gt;C8-\u0026gt;C7。 (2) 下一步，为了分配到fast bin，需要先申请7个，让tcache为空（或calloc），再次申请时就会返回fast bin中的C7，同时由于tcache stash机制，fast bin中剩下的C8,C7均被放入了tcache bin，此时，在C7的fd字段写入target_addr（相当于获得了Edit功能），于是target_addr也被放入了tcache bin，因此这里target_addr处甚至不需要伪造size（target_addr指向user data区）。 (3) 此时，tcache bin中单链表为：C8-\u0026gt;C7-\u0026gt;target_addr，再申请到target_addr，从而得到了一个真正的任意写。 补充：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { void *ptr[15]; for(int i=0;i\u0026lt;=9;i++)ptr[i]=malloc(0x20); for(int i=0;i\u0026lt;7;i++)free(ptr[i]); free(ptr[7]); free(ptr[8]); free(ptr[7]); //free(ptr[9]); for(int i=0;i\u0026lt;7;i++)malloc(0x20); malloc(0x20); return 0; } 上述代码，若是按注释中的写，则在没有触发tcache stash机制时，fast bin中为C9-\u0026gt;C8-\u0026gt;C7，取走C9，最终tcache bin中是C7-\u0026gt;C8，符合设想（依次取C8，C7放入tcache bin）。 然而，若是double free chunk_7，则在没有触发tcache stash机制时，fast bin中为C7-\u0026gt;C8-\u0026gt;C7，取走C7，最终tcache bin中是C8-\u0026gt;C7-\u0026gt;C8，而若是按照tcache bin放入的规则，应该也是类似于C7-\u0026gt;C8，不符合设想。 流程如下： (1) 取C8放入tcache bin，同时REMOVE_FB (fb, pp, tc_victim);会清空C8的next(fd)指针，并且将链表头设置为指向C8原先fd指针指向的堆块C7（源码分析如下）。\n1 2 3 4 5 6 7 8 9 10 #define REMOVE_FB(fb, victim, pp)//摘除一个空闲chunk do { victim = pp; if (victim == NULL) break; } while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-\u0026gt;fd, victim)) != victim); //catomic_compare_and_exchange_val_rel_acq 功能是 如果*fb等于victim，则将*fb存储为victim-\u0026gt;fd，返回victim； //其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-\u0026gt;fd) (2) 目前fast bin中为C7-\u0026gt;C8（最开始取走C7并不清空其fd字段），然后根据tcache bin的放入规则，最终依次放入后为C8-\u0026gt;C7-\u0026gt;C8。\n4.当可以Edit时，往往就不需要double free了，而有些情况看似不能对空闲中的堆块进行Edit（比如存放长度的数组在free后会清零），但是可以利用UAF漏洞对处于空闲状态的堆块进行Edit，例如：\n1 2 3 4 5 malloc(0x20) #1 free(1) malloc(0x20) #2 free(1) #UAF Edit(2, payload) 此时，我们编辑chunk 2，实则是在对已经free的chunk 1进行编辑。\noff by one 缓冲区溢出了一个字节，由于glibc的空间复用技术（即pre_size给上一个allocated的堆块使用），所以可通过off by one修改下一个堆块的size域。 经常是由于循环次数设置有误造成了该漏洞的产生。比较隐蔽的是strcpy会在复制过去的字符串末尾加\\x00，可能造成poison null byte，例如，strlen 和 strcpy 的行为不一致可能会导致off-by-one 的发生：strlen 在计算字符串长度时是不把结束符\\x00计算在内的，但是strcpy在复制字符串时会拷贝结束符 \\x00。 off by one经常可以与Chunk Extend and Overlapping配合使用。\n扩展被释放块： 当可溢出堆块的下一个堆块处在unsorted bin中，可以通过溢出单字节扩大下一个堆块的size域，当申请新size从unsorted bin中取出该堆块时，就会造成堆块重叠，从而控制原堆块之后的堆块。该方法的成功依赖于：malloc并不会对free chunk的完整性以及next chunk的prev_size进行检查，甚至都不会查next chunk的地址是不是个堆块。 libc-2.29增加了检测next chunk的prev_size，会报错：malloc(): mismatching next-\u0026gt;prev_size (unsorted)，也增加了检测next chunk的地址是不是个堆块，会报错malloc(): invalid next size (unsorted)。 libc-2.23(11)的版本，当释放某一个非fast bin的堆块时，若上/下某堆块空闲，则会检测该空闲堆块的size与其next chunk的prev_size是否相等。 扩展已分配块： 当可溢出堆块的一个堆块（通常是fast bin,small bin）处于使用状态中时，单字节溢出可修改处于allocated的堆块的size域，扩大到下面某个处于空闲状态的堆块处，然后将其释放，则会一直覆盖到下面的此空闲堆块，造成堆块重叠。 此时释放处于使用状态的堆块，由于是根据处于使用中的堆块的size找到下一个堆块的，而若是上一个堆块处于使用中，那么下一个堆块的prev_size就不会存放上一个堆块的大小，而是进行空间复用，存放上一个堆块中的数据，因此，此时不论有没有size与next chunk的prev_size的一致性检测，上述利用都可以成功。 同理，若将堆块大小设成0x10的整数倍，就不会复用空间，此时单字节溢出就可以修改next chunk的prev_size域，然后将其释放，就会与上面的更多的堆块合并，造成堆块重叠，当然此时需要next chunk的prev_inuse为零。 当加入了对当前堆块的size与下一个堆块的prev_size的比对检查后，上述利用就难以实现了。 收缩被释放块： 利用poison null byte，即溢出的单字节为\\x00的情况。通过单字节溢出可将下一个被释放块的size域缩小，而此被释放块的下一个堆块（allocated）的prev_size并不会被更改（将已被shrink的堆块进行切割，仍不会改变此prev_size域），若是将此被释放块的下一个堆块释放，则还是会利用原先的prev_size找到上一个被释放块进行合并，这样就造成了堆块重叠。 同样，当加入了对当前堆块的size与下一个堆块的prev_size的比对检查后，上述利用就难以实现了。 house of einherjar： 同样是利用poison null byte，当可溢出堆块的下一个堆块处于使用中时，通过单字节溢出，可修改next chunk的prev_inuse位为零(0x101-\u0026gt;0x100)，同时将prev_size域改为该堆块与目标堆块位置的偏移，再释放可溢出堆块的下一个堆块，则会与上面的堆块合并，造成堆块重叠。值得一提的是，house of einherjar不仅可以造成堆块重叠，还具备将堆块分配到任意地址的能力，只要把上述的目标堆块改为fake chunk的地址即可，因此通常需要泄露堆地址，或者在栈上伪造堆。 unsafe unlink unlink:由经典的链表操作FD=P-\u0026gt;fd;BK=P-\u0026gt;bk;FD-\u0026gt;bk=BK;BK-\u0026gt;fd=FD;实现，这样堆块P就从该双向链表中取出了。 unlink中有一个保护检查机制：(P-\u0026gt;fd-\u0026gt;bk!=P || P-\u0026gt;bk-\u0026gt;fd!=P) == False，需要绕过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; uint64_t *chunk0_ptr; int main() { int malloc_size = 0x80; //避免进入fast bin chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 //chunk0_ptr指向堆块的user data，而\u0026amp;chunk0_ptr是指针的地址，其中存放着该指针指向的堆块的fd的地址 //在0x90的chunk0的user data区伪造一个大小为0x80的fake chunk uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 chunk0_ptr[1] = 0x80; //高版本会有(chunksize(P)!=prev_size(next_chunk(P)) == False)的检查 //绕过检测((P-\u0026gt;fd-\u0026gt;bk!=P || P-\u0026gt;bk-\u0026gt;fd!=P) == False)： chunk0_ptr[2] = (uint64_t) \u0026amp;chunk0_ptr - 0x18; //设置fake chunk的fd //P-\u0026gt;fd-\u0026gt;bk=*(*(P+0x10)+0x18)=*(\u0026amp;P-0x18+0x18)=P chunk0_ptr[3] = (uint64_t) \u0026amp;chunk0_ptr - 0x10; //设置fake chunk的bk //P-\u0026gt;bk-\u0026gt;fd=*(*(P+0x18)+0x10)=*(\u0026amp;P-0x10+0x10)=P uint64_t *chunk1_hdr = chunk1_ptr - 0x10; //chunk1_hdr指向chunk1 header chunk1_hdr[0] = malloc_size; //往上寻找pre(fake) chunk chunk1_hdr[1] \u0026amp;= ~1; //prev_inuse -\u0026gt; 0 //高版本需要先填满对应的tcache bin free(chunk1_ptr); //触发unlink，chunk1找到被伪造成空闲的fake chunk想与之合并，然后对fake chunk进行unlink操作 //P-\u0026gt;fd-\u0026gt;bk=P=P-\u0026gt;bk,P-\u0026gt;bk-\u0026gt;fd=P=P-\u0026gt;fd,即最终P=*(P+0x10)=\u0026amp;P-0x18 char victim_string[8] = \u0026#34;AAAAAAA\u0026#34;; chunk0_ptr[3] = (uint64_t) victim_string; //*(P+0x18)=*(\u0026amp;P)=P=\u0026amp;str chunk0_ptr[0] = 0x42424242424242LL; //*P=*(\u0026amp;str)=str=BBBBBBB fprintf(stderr, \u0026#34;New Value: %s\\n\u0026#34;,victim_string); //BBBBBBB return 0; } unsorted bin attack 1 2 3 `unsorted bin into stack`的原理比较简单，就是在栈上伪造一个堆块，然后修改`unsorted bin`中某堆块的`bk`指针指向此`fake chunk`，通过申请到此`fake chunk`达到对栈上地址的读写权。需要注意的是高版本有`tcache`的情况，此时在`unsorted bin`中找到一个合适大小的堆块后并不会直接返回，而是会放入`tcache bin`中，直到上限，若是某时刻`tcache_count`达到上限，则直接返回该`fake chunk`，不然会继续遍历，并在最后从`tcache bin`中取出返回给用户，此时就要求`fake chunk`的`bk`指针指向自身，这样就可以通过循环绕过。 再来看真正的`unsorted bin attack`，其实在上述利用中，`fake chunk`的`fd`指针被修改成了`unsorted bin`的地址，位于`main_arena`，甚至可以通过泄露其得到`libc`的基地址，当然也可以通过这个利用，将任意地址中的值改成很大的数（如`global_max_fast`），这就是`unsorted bin attack`的核心，其原理是：当某堆块`victim`从`unsorted bin list`中取出时，会进行`bck = victim-\u0026gt;bk; unsorted_chunks(av)-\u0026gt;bk = bck; bck-\u0026gt;fd = unsorted_chunks(av);`的操作。 例如，假设`chunk_A`在`unsorted bin`中，此时将`chunk_A`的`bk`改成`\u0026amp;global_max_fast - 0x10`，然后取出`chunk_A`，那么`chunk_A-\u0026gt;bk-\u0026gt;fd`，也就是`global_max_fast`中就会写入`unsorted bin`地址，即一个很大的数。若是在高版本有`tcache`的情况下，可通过放入`tcache`的次数小于从中取出的次数，从而整型溢出，使得`tcache_count`为一个很大的数，如`0xff`，就可以解决`unsorted bin into stack`中提到的`tcache`特性带来的问题。 large bin attack ​ 假设当前chunk_A在large bin中，修改其bk为addr1 - 0x10，同时修改其bk_nextsize为addr2 - 0x20，此时chunk_B加入了此large bin，其大小略大于chunk_A，将会进行如下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 else { victim-\u0026gt;fd_nextsize = fwd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize;//1 fwd-\u0026gt;bk_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim;//2 } ... bck = fwd-\u0026gt;bk; ... victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd; fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim;//3 ​ 其中，victim就是chunk_B，而fwd就是修改过后的chunk_A，注意到3处bck-\u0026gt;fd = victim，同时，把1带入2可得到：fwd-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize=victim，因此，最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址，也是一个很大的数。\n2-House Of 系列 2.1-House of Spirit [!NOTE]\n对于fast bin，可以在栈上伪造两个fake chunk，但需要绕过检查，应满足第一个fake chunk的标志位IS_MMAPPED与NON_MAIN_ARENA均为零（PREV_INUSE并不影响释放），且要求其大小满足fast bin的大小，对于其next chunk，即第二个fake chunk，需要满足其大小大于0x10，小于av-\u0026gt;system_mem（0x21000）才能绕过检查。之后，伪造指针P = \u0026amp; fake_chunk1_mem，然后free(P)，fake_chunk1就进入了fast bin，之后再申请同样大小的内存，即可取出fake_chunk1，获得了栈上的任意读写权（当然并不局限于在栈上伪造）。 该技术在libc-2.26中仍然适用，可以对tcache做类似的操作，甚至没有对上述next chunk的检查。\n漏洞成因 堆溢出写\n适用范围 2.23—— 至今 利用原理 利用堆溢出，修改 chunk size，伪造出 fake chunk，然后通过堆的释放和排布，控制 fake chunk。house of spirit 的操作思路有很多，比如可以按如下操作进行利用：\n申请 chunk A、chunk B、chunk C、chunk D 对 A 写操作的时候溢出，修改 B 的 size 域，使其能包括 chunk C 释放 B，然后把 B 申请回来，再释放 C，则可以通过读写 B 来控制 C 的内容 相关技巧 起初 house of spirit 主要是针对 fastbin，后来引入了 tcachebin 后，也可以使用 tcachebin 版本的 house of spirit。利用方法与 fastbin 场景下类似，注意好不同版本下的检查条件即可。\n利用效果 劫持 fastbin/tcachebin 的 fd 之后，可以任意地址分配、任意地址读写 2.2-House of Einherjar 漏洞成因 溢出写、off by one、off by null\n适用范围 2.23—— 至今 可分配大于处于 unsortedbin 的 chunk 利用原理 利用 off by null 修改掉 chunk 的 size 域的 P 位，绕过 unlink 检查，在堆的后向合并过程中构造出 chunk overlapping。\n申请 chunk A、chunk B、chunk C、chunk D，chunk D 用来做 gap，chunk A、chunk C 都要处于 unsortedbin 范围 释放 A，进入 unsortedbin 对 B 写操作的时候存在 off by null，修改了 C 的 P 位 释放 C 的时候，堆后向合并，直接把 A、B、C 三块内存合并为了一个 chunk，并放到了 unsortedbin 里面 读写合并后的大 chunk 可以操作 chunk B 的内容，chunk B 的头 相关技巧 虽然该利用技巧至今仍可以利用，但是需要对 unlink 绕过的条件随着版本的增加有所变化。\n最开始的 unlink 的代码是：\n1 2 3 4 5 6 7 8 9 10 /* Take a chunk off a bin list */ #define unlink(AV, P, BK, FD) { FD = P-\u0026gt;fd;\tBK = P-\u0026gt;bk;\tif (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0))\tmalloc_printerr (check_action, \u0026#34;corrupted double-linked list\u0026#34;, P, AV); else {\t// .....\t}\t} 只需要绕过__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0) 即可，因此，不需要伪造地址处于高位的 chunk 的 presize 域。\n高版本的 unlink 的条件是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* Take a chunk off a bin list. */ static void unlink_chunk (mstate av, mchunkptr p) { if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); mchunkptr fd = p-\u0026gt;fd; mchunkptr bk = p-\u0026gt;bk; if (__builtin_expect (fd-\u0026gt;bk != p || bk-\u0026gt;fd != p, 0)) malloc_printerr (\u0026#34;corrupted double-linked list\u0026#34;); // ...... } 新增了 chunksize (p) != prev_size (next_chunk (p))，对 chunksize 有了检查，伪造的时候需要绕过。\n利用效果 构造 chunk overlap 后，可以任意地址分配 结合其他方法进行任意地址读写 2.3-House of Force [!NOTE]\n主要思路为：将top chunk的size改为一个很大的数，就可以始终让top chunk满足切割条件，而恰好又没有对其的检查，故可利用此漏洞，top chunk的地址加上所请求的空间大小造成了整型溢出，使得top chunk被转移到内存中的低地址区域（如bss段，data段，got表等等），接下来再次请求空间，就可以获得转移地址后面的内存区域的控制权。\n直接将top chunk的size域赋成-1，通过整型溢出为0xffffffffffffffff。 将需要申请的evil_size设为target_addr - top_ptr - 0x10*2，这里的top_ptr指向top chunk的chunk header处。 通过malloc(evil_size)申请堆块，此时由于top chunk的size很大，会绕过检查，通过top chunk进行分配，分配后，top chunk被转移到：top_ptr + (evil_size + 0x10) = target_addr - 0x10处。 之后，再申请P = malloc(X)，则此时P指向target_addr，继而可对此地址进行任意读写的操作。 漏洞成因 堆溢出写 top_chunk\n适用范围 2.23——2.29 可分配任意大小的 chunk 需要泄露或已知地址 利用原理 对 top_chunk 的利用，过程如下：\n申请 chunk A 写 A 的时候溢出，修改 top_chunk 的 size 为很大的数 分配很大的 chunk 到任意已知地址 相关技巧 注意，在 glibc-2.29 后加入了检测，house of force 基本失效：\n利用效果 任意地址分配 任意地址读写 2.4-House of Lore 漏洞成因 堆溢出、use after free、edit after free\n适用范围 2.23—— 至今 需要泄露或已知地址 利用原理 控制 smallbin 的 bk 指针，示例如下：\n申请 chunk A、chunk B、chunk C，其中 chunk B 大小位于 smallbin 释放 B，申请更大的 chunk D，使得 B 进入 smallbin 写 A，溢出修改 B 的 bk，指向地址 X，这里有 fake chunk 布置 X-\u0026gt;fd == \u0026amp;B 分配两次后即可取出位于 X 地址处的 fake chunk 相关技巧 在引入了 tcache stash unlink 的时候，需要注意绕过：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #if USE_TCACHE /* While we\u0026#39;re here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) { mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-\u0026gt;counts[tc_idx] \u0026lt; mp_.tcache_count \u0026amp;\u0026amp; (tc_victim = last (bin)) != bin) { if (tc_victim != 0) { bck = tc_victim-\u0026gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != \u0026amp;main_arena) set_non_main_arena (tc_victim); bin-\u0026gt;bk = bck; bck-\u0026gt;fd = bin; tcache_put (tc_victim, tc_idx); } } } #endif 要么使其满足 tc_victim = last (bin)) == bin、要么使其满足：tcache-\u0026gt;counts[tc_idx] ≥ mp_.tcache_count。否则可能会因为非法内存访问使得程序 down 掉。\n实际上，这个技巧用得不是很多，因为在同等条件下，更偏向于利用 fastbin/tcachebin。\n利用效果 任意地址分配 任意地址读写 2.5-House of Orange 漏洞成因 堆溢出写\n适用范围 2.23——2.26 没有 free 可以 unsortedbin attack 利用原理 house of orange 可以说是开启了堆与 IO 组合利用的先河，是非常经典、漂亮、精彩的利用组合技。利用过程还要结合 top_chunk 的性质，利用过程如下：\nstage1\n申请 chunk A，假设此时的 top_chunk 的 size 为 0xWXYZ 写 A，溢出修改 top_chunk 的 size 为 0xXYZ（需要满足页对齐的检测条件） 申请一个大于 0xXYZ 大小的 chunk，此时 top_chunk 会进行 grow，并将原来的 old top_chunk 释放进入 unsortedbin stage2\n溢出写 A，修改处于 unsortedbin 中的 old top_chunk，修改其 size 为 0x61，其 bk 为 \u0026amp;_IO_list_all-0x10，同时伪造好 IO_FILE 结构 申请非 0x60 大小的 chunk 的时候，首先触发 unsortedbin attack，将_IO_list_all 修改为 main_arena+88，然后 unsortedbin chunk 会进入到 smallbin，大小为 0x60；接着遍历 unsortedbin 的时候触发了 malloc_printerr，然后调用链为： malloc_printerr -\u0026gt; libc_message -\u0026gt; abort -\u0026gt; _IO_flush_all_lockp，调用到伪造的 vtable 里面的函数指针 相关技巧 在 glibc-2.24 后加入了 vtable 的 check，不能任意地址伪造 vatble 了，但是可以利用 IO_str_jumps 结构进行利用。 在 glibc-2.26 后，malloc_printerr 不再刷新 IO 流了，所以该方法失效 由于_mode 的正负性是随机的，影响判断条件，大概有 1/2 的概率会利用失败，多试几次就好 利用效果 任意函数执行 任意命令执行 2.6-House of Rabbit [!NOTE]\nhouse of rabbit是利用malloc_consolidate()合并机制的一种方法。 malloc_consolidate()函数会将fastbin中的堆块之间或其中堆块与相邻的freed状态的堆块合并在一起，最后达到的效果就是将合并完成的堆块（或fastbin中的单个堆块）放进了smallbin/largebin中，在此过程中，并不会对fastbin中堆块的size或fd指针进行检查，这是一个可利用点。\nfastbin中的堆块size可控（比如off by one等） 比如现在fastbin有两个0x20的堆块A -\u0026gt; B，其中chunk B在chunk A的上方，我们将chunk B的size改为0x40，这样就正好包含了chunk A，且fake chunk B下面的堆块也就是chunk A下方的堆块，也是合法的，假设这个堆块不是freed的状态，那么触发malloc_consolidate()之后，smallbin里就会有两个堆块，一个是chunk A，另外一个是fake chunk B，其中包含了chunk A，这样就实现了堆块重叠。 fastbin中的堆块fd可控（比如UAF漏洞等） 其实就是将fastbin中的堆块的fd改为指向一个fake chunk，然后通过触发malloc_consolidate()之后，使这个fake chunk完全“合法化”。不过，需要注意伪造的是fake chunk's next chunk的size与其next chunk's next chunk的size（prev_inuse位要为1）。 漏洞成因 堆溢出写、use after free、edit after free\n适用范围 2.23——2.26 超过 0x400 大小的堆分配 可以写 fastbin 的 fd 或者 size 域 利用原理 该利用技巧的核心是 malloc_consolidate 函数，当检测到有 fastbin 的时候，会取出每一个 fastbin chunk，将其放置到 unsortedbin 中，并进行合并。以修改 fd 为例，利用过程如下：\n申请 chunk A、chunk B，其中 chunk A 的大小位于 fastbin 范围 释放 chunk A，使其进入到 fastbin 利用 use after free，修改 A-\u0026gt;fd 指向地址 X，需要伪造好 fake chunk，使其不执行 unlink 或者绕过 unlink 分配足够大的 chunk，或者释放 0x10000 以上的 chunk，只要能触发 malloc_consolidate 即可 此时 fake chunk 被放到了 unsortedbin，或者进入到对应的 smallbin/largebin 取出 fake chunk 进行读写即可 相关技巧 2.26 加入了 unlink 对 presize 的检查 2.27 加入了 fastbin 的检查 抓住重点：house of rabbit 是对 malloc_consolidate 的利用。因此，不一定要按照原作者的思路来，他的思路需要满足的条件太多了。\n利用效果 任意地址分配 任意地址读写 2.7-House of Roman 漏洞成因 use after free、堆溢出\n适用范围 2.23——2.29 可以 use after edit 不需要泄露地址 需要爆破 12 bit，成功的概率 1/4096 利用原理 可以说这个技巧是 fastbin attack + unsortedbin attack 的组合技，利用思路如下：\n申请 chunk A、chunk B、chunk C 和 chunk D，chunk B 的大小为 0x70 释放 chunk B，使其进入到 fastbin[0x70] 溢出写 A，修改 chunk B 的 size，使其大小在 unsortedbin 范围 再次释放 B，B 进入 unsortedbin 中 部分写 B 的 fd，使得 fd 指向 malloc_hook-0x23 利用 A 的溢出写修正 B 的 size，连续分配两次 0x70，即可分配到 malloc_hook 上方 触发 unsortedbin attack，将__malloc_hook 写为 main_arena+88 部分写__malloc_hook 的低三个字节，修改为 one_gadget 再次 malloc 即可拿到 shell 相关技巧 使用 house of roman 的时候，需要采用多线程爆破 可以使用其他方法代替，比如先攻击 stdout 泄露地址，使得爆破的成本降低 利用效果 执行 one_gadget 绕过 ASLR 2.8-House of Storm 漏洞成因 堆溢出、use after free、edit after free\n适用范围 2.23——2.29 可以进行 unsortedbin attack 可以进行 largebin attack，修改 bk 和 bk_nextsize 可以分配 0x50 大小的 chunk 利用原理 house of storm 也是一款组合技，利用开启了 PIE 的 x64 程序的堆地址总是 0x55xxxx... 或者 0x56xxxx... 开头这一特性，使用一次 largebin attack 写两个堆地址，使用一次 unsortedbin attack 写一次 libc 地址，可以实现任意地址分配。虽然 house of storm 最后能达到任意地址分配，但是由于其所需的条件比较多，一般可以用其他更简便的堆利用技术代替。利用思路如下：\n进行一次 unsortedbin attack，其 bk 修改为 addr 进行一次 largebin attack，其 bk 修改为 addr+0x10，bk_nextsize 修改为 addr-0x20+3 申请 0x50 大小的 chunk 即可申请到 addr 处 相关技巧 需要注意的有：\n该方法成功的几率是 50%，因为 0x55 会触发 assert 断言，0x56 才能成功 申请 addr 处的 chunk 的时候需要从 unsortedbin 里面取 利用效果 任意地址分配 2.9-House of Corrosion 漏洞成因 堆溢出、use after free\n适用范围 2.23—— 至今 任意大小分配 可以修改 global_max_fast 不需要泄露地址 利用原理 一个非常 tricky 的方法，可以绕过 aslr，不需要泄露地址都能达成 rce，可以很很多方法结合起来应用。先说利用原理：\n使用 unsortedbin attack/largebin attack 等方法，成功修改 global_max_fast 的值为很大的值。如果使用 unsortedbin attack，不需要泄露地址，爆破 1/16 即可 申请任意大小的 chunk，这些 chunk 都会被视为 fastbin chunk，然后利用这些 chunk 来进行读和写 此时的计算公式为：\n1 chunk size = (chunk addr - \u0026amp;main_arena.fastbinsY) x 2 + 0x20 读原语：\n假设对应的地址 X 上存储着 Y，现在的目的是泄露出 Y 根据偏移计算出来 chunk size，修改 chunk A 的 size 为计算出来的值，释放 chunk A 到地址 X 处 此时，A-\u0026gt;fd 就被写入了 Y 通过打印即可泄露出 Y 的信息 写原语 1：\n假设对应的地址 X 上存储着 Y，现在的目的是修改地址 X 存储的 Y 为其他值 根据偏移计算出来 chunk size，修改 chunk A 的 size 为计算出来的值，释放 chunk A 到地址 X 处 此时，A-\u0026gt;fd 就被写入了 Y 修改 A-\u0026gt;fd 为目标值 分配一次 chunk A 就可以把地址 X 存储的值为任意值 写原语 2：\n假设地址 X 上存储着 Y、地址 M 上存储着 N，现在的目的是把 N 写到地址 X 处 根据偏移计算 chunk size1，先释放 chunk A 到地址 X 处，此时有地址 X 处存储 chunk A 地址，chunk A-\u0026gt;fd 为 Y 根据偏移计算 chunk size2，再次释放 chunk A 到地址 M 处，此时有地址 M 处存储 chunk A 地址，chunk A-\u0026gt;fd 为 N 修正 chunk A 的大小为 chunk size1，分配 1 次 chunk 即可使得 N 转移到地址 X 处，当然在转移的过程中可以适当的修改 N 显然，借助写原语 2，即可在不需要泄露地址的前提下将__malloc_hook 等写为 one_gadget，爆破的概率是 1/4096。\n相关技巧 虽然至今都能使用 house of corrosion，但是在 glibc-2.37 版本中，global_max_fast 的数据类型被修改为了 int8_u，进而导致可控的空间范围大幅度缩小。 house of corrosion 也可以拓展到 tcachebin 上 适当控制 global_max_fast 的大小，把握控制的空间范围 可以和 IO_FILE 结合起来泄露信息 利用效果 glibc 上的地址泄露 执行 one_gadget 2.10-House of Husk 漏洞成因 堆溢出\n适用范围 2.23—— 至今 可以修改__printf_arginfo_table 和__printf_function_table 可触发格式化字符串解析 利用原理 严格来说，这个漏洞是与堆的关系并不是很大，主要是根据 printf 的机制进行利用。但是，该技术可以和很多堆利用手法结合起来。\n调用处 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // /* Use the slow path in case any printf handler is registered. */ if (__glibc_unlikely (__printf_function_table != NULL || __printf_modifier_table != NULL || __printf_va_arg_table != NULL)) goto do_positional; // vfprintf-internal.c#1763 nargs += __parse_one_specmb (f, nargs, \u0026amp;specs[nspecs], \u0026amp;max_ref_arg); // printf-parsemb.c (__parse_one_specmb函数) /* Get the format specification. */ spec-\u0026gt;info.spec = (wchar_t) *format++; spec-\u0026gt;size = -1; if (__builtin_expect (__printf_function_table == NULL, 1) // 判断是否为空 || spec-\u0026gt;info.spec \u0026gt; UCHAR_MAX || __printf_arginfo_table[spec-\u0026gt;info.spec] == NULL // 判断是否为空 /* We don\u0026#39;t try to get the types for all arguments if the format uses more than one. The normal case is covered though. If the call returns -1 we continue with the normal specifiers. */ || (int) (spec-\u0026gt;ndata_args = (*__printf_arginfo_table[spec-\u0026gt;info.spec]) // 调用__printf_arginfo_table中的函数指针 (\u0026amp;spec-\u0026gt;info, 1, \u0026amp;spec-\u0026gt;data_arg_type, \u0026amp;spec-\u0026gt;size)) \u0026lt; 0) { // ...... } 利用方式为：\n__printf_function_table 和__printf_arginfo_table 分别写为 chunk A 和 chunk B 的地址 设占位符为 α，此时 chunk B 的内容应该为 p64(0) x ord(α-2) + p64(one_gadget) 调用处 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // vfprintf-internal.c#1962 if (spec \u0026lt;= UCHAR_MAX \u0026amp;\u0026amp; __printf_function_table != NULL \u0026amp;\u0026amp; __printf_function_table[(size_t) spec] != NULL) { // ...... /* Call the function. */ function_done = __printf_function_table[(size_t) spec](s, \u0026amp;specs[nspecs_done].info, ptr); // 调用__printf_function_table中的函数指针 if (function_done != -2) { /* If an error occurred we don\u0026#39;t have information about # of chars. */ if (function_done \u0026lt; 0) { /* Function has set errno. */ done = -1; goto all_done; } done_add (function_done); break; } } 利用方式为：\n__printf_function_table 和__printf_arginfo_table 分别写为 chunk A 和 chunk B 的地址 设占位符为 α，此时 chunk A 的内容应该为 p64(0) x ord(α-2) + p64(one_gadget) 该处调用在高版本被删除。\n相关技巧 该技巧一般和 largebin attack 结合起来 在低于 2.36 版本中，__malloc_assert 中有格式化字符串的解析 还有一个__printf_va_arg_table 也是可以利用的，但是条件比较苛刻 利用效果 执行 one_gadget 执行 rop 控制程序执行流 2.11-House of Atum 漏洞成因 1 edit after free 适用范围 2.26——2.30 可以修改 tcachebin 的 next 和 key 利用原理 这是一个关于 tcachebin 的技巧，用于修改 chunk presize/size，利用过程如下：\n申请 chunk A，大小在 fastbin 范围内 释放 A，连续释放 8 次，此时，A 的 fd 被清 0，A 也被放置到了 fastbin 里面 申请一个 chunk，将其 fd 修改为 A - 0x10，此时 tcache 中的 counts 为 6 再申请一个 chunk，从 fastbin 里面取，但是会把 fastbin 里面剩余的一个 chunk 链入到 tcachebin 再次分配就会分配到地址 A-0x10 处，就可以修改原来 A 的 presize/size 等 相关技巧 2.30 之后逻辑变了，原来是判断 entry[idx]!=NULL，2.31 之后判断 count[idx] \u0026gt; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // glibc ≥ 2.30 void * __libc_malloc (size_t bytes) { //...... MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx \u0026lt; mp_.tcache_bins \u0026amp;\u0026amp; tcache \u0026amp;\u0026amp; tcache-\u0026gt;counts[tc_idx] \u0026gt; 0) { return tcache_get (tc_idx); } } // glibc \u0026lt; 2.30 void * __libc_malloc (size_t bytes) { //...... MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx \u0026lt; mp_.tcache_bins \u0026amp;\u0026amp; tcache \u0026amp;\u0026amp; tcache-\u0026gt;entries[tc_idx] != NULL) { return tcache_get (tc_idx); } } 有时候需要绕过 tcache-\u0026gt;key 的检测 利用效果 修改 chunk size 以及 chunk presize 2.12-House of Kauri 漏洞成因 堆溢出\n适用范围 2.26——2.32 利用原理 利用原理很简单，修改 tcachebin 的 size，然后使其被放到不同大小的 tcachebin 链表里面去。我感觉这个技巧是很基础的 tcachebin 技巧，甚至不应该被称之为 house of。\n相关技巧 无 利用效果 多个 tcachebin 链表中存放同一个 chunk 2.13-House of Fun 漏洞成因 堆溢出、use after free\n适用范围 2.23——2.30 可以申请 largebin 范围的 chunk 利用原理 或许这个技巧应该叫做 largebin attack。\n在这个 sourceware.org Git - glibc.git/blobdiff - malloc/malloc.ccommit 被检测了：\n相关技巧 无 利用效果 任意地址写堆地址 2.14-House of Mind 漏洞成因 堆溢出\n适用范围 2.23—— 至今 可以分配任意大小的 chunk 利用原理 主要利用的是：\n1 2 3 4 #define heap_for_ptr(ptr) \\ ((heap_info *) ((unsigned long) (ptr) \u0026amp; ~(HEAP_MAX_SIZE - 1))) #define arena_for_chunk(ptr) \\ (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-\u0026gt;ar_ptr : \u0026amp;main_arena) 如果是 non-mainarean 的 chunk，会根据其地址找到 heapinfo，然后找到 malloc_state 结构体。\n因此，利用技巧是：\n根据要释放的 fastbin chunk A 的堆地址，找到对应的 heap_for_ptr 地址 在 heapinfo 地址处伪造好相关变量，重点是 mstate 指针 修改 chunk A 的 non-main 标志位，释放到伪造的 arena 里面，控制好偏移即可 相关技巧 一般来说，可以分配任意大小的 chunk，还能堆溢出，很多技巧都能用 这个技巧是希望大家关注对于 arena 的攻击 甚至可以直接修改 thread_arena 这个变量 利用效果 任意地址写堆地址 2.15-House of Muney 漏洞成因 堆溢出\n适用范围 2.23—— 至今 能分配 mmap 的 chunk 能修改 mmap 的 chunk 的大小 利用原理 这个技巧被称之为 steal heap from glibc。主要的点有以下几个：\nlibc.so.6 映射的地址空间，前面都是与符号表、哈希表、字符串表等重定位或者解析函数地址有关，前面一段的权限是 r-- mmap(NULL, ...) 是会分配到 libc.so.6 的上方的 基于这两个知识点，利用过程如下：\n申请 chunk A，假设为 0x40000 大小，则会走 mmap 申请，并且申请到 libc.so.6 的上方 修改 chunk A 的大小为 0x45000，设置 MMAP 标志位 释放 chunk A，则会把 libc.so.6 的 0x5000 的内存也释放掉 再次申请 0x45000，就可以控制 libc.so.6 原来的符号表、哈希表等等 触发一次 dl_runtime_resolve 等就能控制程序执行任意代码 相关技巧 需要伪造的符号表、哈希表等需要逐步调试 可以扩展为 steal heap from everywhere 利用效果 任意代码执行 2.16-House of Botcake 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 在 2.29/2.27 高版本之后，glibc 为了防止攻击者简单的 Tcache Double Free，引入了对 Tcache Key 的检查 size_t tc_idx = csize2tidx (size); if (tcache != NULL \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) { /* Check to see if it\u0026#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don\u0026#39;t 100% trust it (it also matches random payload data at a 1 in 2^\u0026lt;size_t\u0026gt; chance), so verify it\u0026#39;s not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-\u0026gt;key == tcache)) { tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-\u0026gt;entries[tc_idx]; tmp; tmp = tmp-\u0026gt;next) if (tmp == e) malloc_printerr (\u0026#34;free(): double free detected in tcache 2\u0026#34;); /* If we get here, it was a coincidence. We\u0026#39;ve wasted a few cycles, but don\u0026#39;t abort. */ } 1）破坏掉被free的堆块的Key，这样就不会进入第一层检查 2）改变被free的堆块的大小，这样虽然进入了第一层检查，但是在进行第二层遍历相同大小的Tcache链表的时候，由于glibc进入的是另一个大小的Tcache链表中去检查，所以也不会被第二层检查发现 3）house of botcake\n漏洞成因 1 double free 适用范围 2.26—— 至今 多次释放 chunk 的能力 利用原理 该技巧可以用于绕过 tcache-\u0026gt;key 的检查，利用过程如下：\n申请 7 个大小相同，大小大于 0x80 的 chunk，再申请三个，分别为 chunk A 和 chunkB 和 chunk C 释放前 7 个chunk和 chunk A，(前面 7 个都会进入到 tcachebin 里面，chunk A 进入到 unsortedbin) 释放 chunk B，则 chunk B 会和 chunk A 合并 从 tcachebin 分配走一个 再次释放 chunk B，此时 B 同时存在与 unsortedbin 和 tcachebin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c //分配七个填充堆块（小于最大的Tcache，大于最大的Fastbin），一个辅助堆块 prev ，一个利用堆块 victim intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } intptr_t *prev = malloc(0x100); intptr_t *victim = malloc(0x100); malloc(0x10); // 防止合并 //free 掉七个填充堆块，此时对应大小的 Tcache 被填满 for(int i=0; i\u0026lt;7; i++){ free(x[i]); } //free 掉利用堆块 victim，由于此时 Tcache 被填满，victim 进入 Unsortedbin（绕过了 key 的产生） free(victim); //free 掉辅助堆块 prev，此时俩 Unsortedbin 相邻，会触发 Unsortedbin Consolidate 合并成一个大堆块 free(prev); //申请出一个堆块，此时会优先从 Tcache 中取出一个填充堆块腾出位置。然后再 Free 掉 victim ，victim 进入 Tcache，完成 Double Free malloc(0x100); /*VULNERABILITY*/ free(victim);// victim is already freed /*VULNERABILITY*/ House of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。\n此外 House of botcake 在条件合适的情况下，极其容易完成多次任意分配堆块，是相当好用的手法。\n相关技巧 在高版本需要绕过指针保护的检查 利用效果 构造出堆重叠，为后续利用做准备 2.17-House of Rust 漏洞成因 堆溢出\n适用范围 2.26—— 至今 可以进行 tcache stash unlinking 攻击 可以进行 largebin attack 不需要泄露地址 利用原理 原作者的博客写得很复杂，我这里提炼出关键信息。该技巧就是 tcachebin stash unlinking+largebin attack 的组合技巧。\n首先需要知道 tcachebin stash unlinking，下面称之为 TSU 技巧：\ntcachebin[A] 为空 smallbin[A] 有 8 个 修改第 8 个 smallbin chunk 的 bk 为 addr 分配 malloc(A) 的时候，addr+0x10 会被写一个 libc 地址 还要知道 tcachebin stash unlinking+，下面称之为 TSU+ 技巧：\ntcachebin[A] 为空 smallbin[A] 有 8 个 修改第 7 个 smallbin chunk 的 bk 为 addr，还要保证 addr+0x18 是一个合法可写的地址 分配 malloc(A) 的时候，addr 会被链入到 tcachebin，也就是可以分配到 addr 处 以 0x90 大小的 chunk 为例，此时的 tcache_key 还是指向 tcache_perthread_struct + 0x10 的：\n第一步，把 tcachebin[0x90] 填满，把 smallbin[0x90] 也填满 第二步，把最后一个 smallbin 0x90 的 chunk 的 size 改成 0xb0，将其释放到 tcachebin[0xb0]，这一步主要是为了改变其 bk 指向 tcache_perthread_struct + 0x10，可以部分修改低位的字节，以便下一步分配到目标区域 第三步，使用 largebin attack 往上一步的 bk-\u0026gt;bk 写一个合法地址，然后耗尽 tcachebin[0x90]，再分配的时候就会触发 TSU+，之后就能分配到 tcache_perthread_struct 结构体 第四步，还是堆风水，但是用 TSU 技术，在 tcache_perthread_struct 上写一个 libc 地址（比前面一步要简单很多） 第五步，通过控制 tcache_perthread_struct 结构体，部分写上面的 libc 地址，分配到 stdout 结构体，泄露信息 第六步，通过控制 tcache_perthread_struct 结构体分配到任意地址 上面的过程最好的情况下需要爆破 1/16，最差 1/256。\n但是，2.34 之后，tcache_key 是一个随机数，不是 tcache_perthread_struct + 0x10 了。\n所以，此时可以加上 largebin attack，把以上的第二步变为：继续用 largebin attack 向其 bk 写一个堆地址，然后还要部分写 bk 使其落在 tcache_perthread_struct 区域。其他步骤一样。\n或者，在 smallbin 里面放 9 个，这样第 8 个的 bk 肯定就是一个堆地址。此时就需要爆破 1/16 的堆，1/16 的 glibc 地址，成功的概率是 1/256。\n相关技巧 总的来说，就是利用 tcachebin stash unlinking 打 tcache_perthread_struct 利用 largebin attack 构造合法地址 利用效果 任意地址分配 任意函数执行 2.18-House of Crust 漏洞成因 堆溢出\n适用范围 2.26——2.37 可以进行 tcache stash unlinking 攻击 可以进行 largebin attack 不需要泄露地址 利用原理 其他步骤和上面的 house of rust 一样，但是到第五步的时候，去修改 global_max_fast\n后面的步骤和 house of corrosion 是一样的，通过写原语打 stderr 修改 one_gadget 拿到 shell。\n相关技巧 house of crust = house of corrosion + house of rust 2.37 之后，house of corrosion 使用受限 2.19-House of Io 漏洞成因 堆溢出\n适用范围 2.26—— 至今 利用原理 其他博客上对该方法的介绍如下：\n1 The tcache_perthread_object is allocated when the heap is created. Furthermore, it is stored right at the heap\u0026#39;s beginning (at a relatively low memory address). The safe-linking mitigation aims to protect the fd/next pointer within the free lists. However, the head of each free-list is not protected. Additionally, freeing a chunk and placing it into the tcachebin also places a non-protected pointer to the appropriate tcache entry in the 2nd qword of a chunks\u0026#39; user data. The House of IO assumes one of three scenarios for the bypass to work. First, any attacker with a controlled linear buffer underflow over a heap buffer, or a relative arbitrary write will be able to corrupt the tcache. Secondly, a UAF bug allowing to read from a freed tcache eligible chunk leaks the tcache and with that, the heap base. Thirdly, a badly ordered set of calls to free(), ultimately passing the address of the tcache itself to free, would link the tcache into the 0x290 sized tcachebin. Allocating it as a new chunk would mean complete control over the tcache\u0026#39;s values. 可以看出来，其实就是对 tcache_perthread_struct 结构体的攻击，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个 tcache 的分配。\n相关技巧 围绕 tcache_perthread_struct 进行攻击 利用效果 任意地址分配 2.20-House of Banana 漏洞成因 堆溢出\n适用范围 2.23—— 至今 可以进行 largebin attack 能执行 exit 函数 利用原理 首先是 largebin attack 在高版本只能从下面这个分支利用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* maintain large bins in sorted order */ if (fwd != bck) { /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-\u0026gt;bk)); if ((unsigned long) (size) \u0026lt; (unsigned long) chunksize_nomask (bck-\u0026gt;bk)) { fwd = bck; bck = bck-\u0026gt;bk; victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } else { //...... } //...... } 也就是，双链表里面至少存在一个 largebin chunk，且目前要入链的 chunk 比最小的还小，修改了 bk_nextsize 之后就会触发。可以造成任意地址写堆地址。\n然后是 exit 调用的时候，会调用到_dl_fini 函数，执行每个 so 中注册的 fini 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 for (i = 0; i \u0026lt; nmaps; ++i) { struct link_map *l = maps[i]; if (l-\u0026gt;l_init_called) { /* Make sure nothing happens if we are called twice. */ l-\u0026gt;l_init_called = 0; /* Is there a destructor function? */ if (l-\u0026gt;l_info[DT_FINI_ARRAY] != NULL || (ELF_INITFINI \u0026amp;\u0026amp; l-\u0026gt;l_info[DT_FINI] != NULL)) { /* When debugging print a message first. */ if (__builtin_expect (GLRO(dl_debug_mask) \u0026amp; DL_DEBUG_IMPCALLS, 0)) _dl_debug_printf (\u0026#34;\\ncalling fini: %s [%lu]\\n\\n\u0026#34;, DSO_FILENAME (l-\u0026gt;l_name), ns); /* First see whether an array is given. */ if (l-\u0026gt;l_info[DT_FINI_ARRAY] != NULL) { ElfW(Addr) *array = (ElfW(Addr) *) (l-\u0026gt;l_addr + l-\u0026gt;l_info[DT_FINI_ARRAY]-\u0026gt;d_un.d_ptr); unsigned int i = (l-\u0026gt;l_info[DT_FINI_ARRAYSZ]-\u0026gt;d_un.d_val / sizeof (ElfW(Addr))); while (i-- \u0026gt; 0) ((fini_t) array[i]) (); // 这里call } /* Next try the old-style destructor. */ if (ELF_INITFINI \u0026amp;\u0026amp; l-\u0026gt;l_info[DT_FINI] != NULL) DL_CALL_DT_FINI (l, l-\u0026gt;l_addr + l-\u0026gt;l_info[DT_FINI]-\u0026gt;d_un.d_ptr); // 这里call } 可以触发 call 的有两个点，第一个点可以 call 到很多指针，是一个数组；另一个点就只有一个函数。\n剩下的工作就是根据代码绕过检测，调用到调用点。\n所以，利用的思路有：\n直接伪造_rtld_global 的_ns_loaded，布局好其他内容，使其调用到 fini_array 伪造 link_map 的 next 指针，布局好其他内容，使其调用到 fini_array 修改 link_map-\u0026gt;l_addr，根据偏移使其调用到指定区域的函数 相关技巧 伪造 fini_array 数组的时候，是从后往前遍历的 有时候远程的 rtld_global 的偏移与本地不一样，需要爆破 如果不想逐个伪造，可以直接用 gdb 从内存里面 dump 出来，然后基于偏移修改内存即可 利用效果 任意代码执行 2.21-House of Kiwi 漏洞成因 堆溢出\n适用范围 2.23——2.36 在 malloc 流程中触发 assert 利用原理 主要是提供了一种在程序中调用 IO 流函数的思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #if IS_IN (libc) #ifndef NDEBUG # define __assert_fail(assertion, file, line, function)\t__malloc_assert(assertion, file, line, function) extern const char *__progname; static void __malloc_assert (const char *assertion, const char *file, unsigned int line, const char *function) { (void) __fxprintf (NULL, \u0026#34;%s%s%s:%u: %s%sAssertion `%s\u0026#39; failed.\\n\u0026#34;, __progname, __progname[0] ? \u0026#34;: \u0026#34; : \u0026#34;\u0026#34;, file, line, function ? function : \u0026#34;\u0026#34;, function ? \u0026#34;: \u0026#34; : \u0026#34;\u0026#34;, assertion); fflush (stderr); abort (); } #endif #endif 可以看到，调用到了 fxprintf 和 fflush。\n至于原 house of kiwi 所提到的控制 rdx 的思路，在很多版本中无法使用，因为 IO_jumps_table 都是不可写的，故此处不再详述。\n相关技巧 在 2.36 之后，__malloc_assert 被修改为： 1 2 3 4 5 6 7 8 9 _Noreturn static void __malloc_assert (const char *assertion, const char *file, unsigned int line, const char *function) { __libc_message (do_abort, \u0026#34;\\ Fatal glibc error: malloc assertion failure in %s: %s\\n\u0026#34;, function, assertion); __builtin_unreachable (); } 而在 2.37 该函数直接被删掉了。\n如果 stderr 在 libc 上，需要修改调 stderr 处的指针，也有可能在程序的地址空间上 伪造的技巧如下，触发 fxprintf(stderr，......)： 1 2 3 4 5 flags \u0026amp; 0x8000的话，不用伪造_lock flags \u0026amp; ~(0x2 | 0x8) 必须成立，避免走到unbuffered的流程 mode 设置为0 vtable默认调用的是偏移0x38的函数，如果想劫持为_IO_xxx_overflow，需要设置为_IO_xxx_jumps-0x20 flags 可以设置为\u0026#34; sh||\u0026#34;，前面有两个空格，此时还需要设置_lock，不想设置_lock的时候，flags可以为\u0026#34;\\x20\\x80;sh||\u0026#34; 利用效果 触发 IO 处理流程，为后续利用做准备 2.22-House of Emma 漏洞成因 堆溢出\n适用范围 2.23—— 至今 可以进行两次 largebin attack 或者可以进行两次任意地址写堆地址 可以触发 IO 流操作 利用原理 在_IO_cookie_jumps 中存在一些_IO_cookie_read 等函数，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 static ssize_t _IO_cookie_read (FILE *fp, void *buf, ssize_t size) { struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp; cookie_read_function_t *read_cb = cfile-\u0026gt;__io_functions.read; #ifdef PTR_DEMANGLE PTR_DEMANGLE (read_cb); #endif if (read_cb == NULL) return -1; return read_cb (cfile-\u0026gt;__cookie, buf, size); } 可以看到有函数指针的调用。但是对函数指针使用 pointer_guard 进行了加密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # define PTR_MANGLE(var)\tasm (\u0026#34;xorl %%gs:%c2, %0\\n\u0026#34;\t\\ \u0026#34;roll $9, %0\u0026#34;\t\\ : \u0026#34;=r\u0026#34; (var)\t\\ : \u0026#34;0\u0026#34; (var),\t\\ \u0026#34;i\u0026#34; (offsetof (tcbhead_t,\t\\ pointer_guard))) # define PTR_DEMANGLE(var)\tasm (\u0026#34;rorl $9, %0\\n\u0026#34;\t\\ \u0026#34;xorl %%gs:%c2, %0\u0026#34;\t\\ : \u0026#34;=r\u0026#34; (var)\t\\ : \u0026#34;0\u0026#34; (var),\t\\ \u0026#34;i\u0026#34; (offsetof (tcbhead_t,\t\\ pointer_guard))) # endif 循环右移后，再异或。\n因此，利用思路如下：\n截至某个 IO_FILE 的指针（IO_list_all/stdxxx-\u0026gt;chain 等都可以）为堆地址 堆上伪造 IO_FILE 结构，其 vtable 替换为_IO_cookie_jumps+XX，XX 为一个偏移量 伪造好函数指针和调用参数，指针需要循环异或和加密 调用到_IO_cookie_read 等函数，进而执行任意函数 相关技巧 常用的 gadget 有： 1 2 3 4 5 6 7 8 9 10 11 12 13 ;栈迁移 mov rbp,QWORD PTR [rdi+0x48] mov rax,QWORD PTR [rbp+0x18] lea r13,[rbp+0x10] mov DWORD PTR [rbp+0x10],0x0 mov rdi,r13 call QWORD PTR [rax+0x28] ; rdi转rdx mov rdx, qword ptr [rdi + 8] mov qword ptr [rsp], rax call qword ptr [rdx + 0x20] pointer_guard 就在 canary 下面，偏移可能需要爆破 利用效果 任意函数执行 2.23-House of Pig 漏洞成因 堆溢出\n适用范围 2.23—— 至今 可以进行 largebin attack 可以触发 IO 流操作 利用原理 在_IO_str_jumps 中，存在着_IO_str_overflow 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int _IO_str_overflow (FILE *fp, int c) { int flush_only = c == EOF; size_t pos; if (fp-\u0026gt;_flags \u0026amp; _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-\u0026gt;_flags \u0026amp; _IO_TIED_PUT_GET) \u0026amp;\u0026amp; !(fp-\u0026gt;_flags \u0026amp; _IO_CURRENTLY_PUTTING)) { fp-\u0026gt;_flags |= _IO_CURRENTLY_PUTTING; fp-\u0026gt;_IO_write_ptr = fp-\u0026gt;_IO_read_ptr; fp-\u0026gt;_IO_read_ptr = fp-\u0026gt;_IO_read_end; } pos = fp-\u0026gt;_IO_write_ptr - fp-\u0026gt;_IO_write_base; if (pos \u0026gt;= (size_t) (_IO_blen (fp) + flush_only)) { if (fp-\u0026gt;_flags \u0026amp; _IO_USER_BUF) /* not allowed to enlarge */ return EOF; else { char *new_buf; char *old_buf = fp-\u0026gt;_IO_buf_base; // 覆盖到这里 size_t old_blen = _IO_blen (fp); size_t new_size = 2 * old_blen + 100; if (new_size \u0026lt; old_blen) return EOF; new_buf = malloc (new_size); // 调用malloc if (new_buf == NULL) { /*\t__ferror(fp) = 1; */ return EOF; } if (old_buf) { memcpy (new_buf, old_buf, old_blen);// 调用memecpy，覆盖 free (old_buf); // 调用free /* Make sure _IO_setb won\u0026#39;t try to delete _IO_buf_base. */ fp-\u0026gt;_IO_buf_base = NULL; } memset (new_buf + old_blen, \u0026#39;\\0\u0026#39;, new_size - old_blen); //...... } } 从函数中就能看到，利用流程如下：\n伪造 IO_FILE 的_IO_buf_base 合理控制_IO_buf_end-_IO_buf_base 的值，进而控制分配的 chunk 的大小，分配到布局好的地址 在 memcpy 中覆盖地址，如可以覆盖__malloc_hook/__free_hook 等 该方法需要结合其他堆利用技术，需要保证 malloc 分配出来的 chunk 的地址是可控的。该方法主要提供了对 IO 系列函数中间接调用 mallc/free/memcpy 的组合利用。\n相关技巧 可以 largebin attack 打掉 mp_.tcachebins，进而能把很大的 chunk 也放进入 tcache 进行管理 高版本没有 hook 的话，可以利用 memcpy@got，通过覆写 got 来进行 rce 可以多次 house of pig 组合调用 利用效果 任意函数执行 ROP 控制程序执行流 2.24-House of Obstack 漏洞成因 堆溢出\n适用范围 2.23—— 至今 可以执行一次 largebin attack 可以触发 IO 流操作 利用原理 一条新的利用链，伪造 vtable 为_IO_obstack_jumps，然后调用到_IO_obstack_xsputn，紧接着调用 obstack_grow，其代码为：\n1 2 3 4 5 6 7 8 9 #define obstack_grow(OBSTACK, where, length) \\ __extension__ \\ ({ struct obstack *__o = (OBSTACK); \\ int __len = (length); \\ if (_o-\u0026gt;next_free + __len \u0026gt; __o-\u0026gt;chunk_limit) \\ _obstack_newchunk (__o, __len); \\ memcpy (__o-\u0026gt;next_free, where, __len); \\ __o-\u0026gt;next_free += __len; \\ (void) 0; }) 然后在_obstack_newchunk 调用了 CALL_CHUNKFUN 这个宏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void _obstack_newchunk (struct obstack *h, int length) { struct _obstack_chunk *old_chunk = h-\u0026gt;chunk; struct _obstack_chunk *new_chunk; long new_size; long obj_size = h-\u0026gt;next_free - h-\u0026gt;object_base; long i; long already; char *object_base; /* Compute size for new chunk. */ new_size = (obj_size + length) + (obj_size \u0026gt;\u0026gt; 3) + h-\u0026gt;alignment_mask + 100; if (new_size \u0026lt; h-\u0026gt;chunk_size) new_size = h-\u0026gt;chunk_size; /* Allocate and initialize the new chunk. */ new_chunk = CALL_CHUNKFUN (h, new_size); [...] } 这个宏会调用到函数指针：\n1 2 3 4 # define CALL_CHUNKFUN(h, size) \\ (((h)-\u0026gt;use_extra_arg) \\ ? (*(h)-\u0026gt;chunkfun)((h)-\u0026gt;extra_arg, (size)) \\ : (*(struct _obstack_chunk *(*)(long))(h)-\u0026gt;chunkfun)((size))) 因此，其就是利用该函数指针进行控制程序的执行流。\n相关技巧 伪造的 IO_FILE 布局如下：\n利用 largebin attack 伪造_IO_FILE，记完成伪造的 chunk 为 A（或者别的手法） chunk A 内偏移为 0xd8 处设为_IO_obstack_jumps+0x20 chunk A 内偏移为 0xe0 处设置 chunk A 的地址作为 obstack 结构体 chunk A 内偏移为 0x18 处设为 1（next_free) chunk A 内偏移为 0x20 处设为 0（chunk_limit） chunk A 内偏移为 0x48 处设为 \u0026amp;/bin/sh chunk A 内偏移为 0x38 处设为 system 函数的地址 chunk A 内偏移为 0x28 处设为 1（_IO_write_ptr) chunk A 内偏移为 0x30 处设为 0 (_IO_write_end) chunk A 内偏移为 0x50 处设为 1 (use_extra_arg) glibc-2.37 开始这个方法的调用链为：__printf_buffer_as_file_overflow -\u0026gt; __printf_buffer_flush -\u0026gt; __printf_buffer_flush_obstack-\u0026gt;__obstack_newchunk。\n利用效果 任意函数执行 2.25-House of Apple1 漏洞成因 堆溢出\n适用范围 2.23—— 至今 程序从 main 函数返回或能调用 exit 函数 能泄露出 heap 地址和 libc 地址 能使用一次 largebin attack（一次即可） 利用原理 利用_IO_wstr_overflow 将任意地址存储的值修改已知值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 static wint_t _IO_wstrn_overflow (FILE *fp, wint_t c) { /* When we come to here this means the user supplied buffer is filled. But since we must return the number of characters which would have been written in total we must provide a buffer for further use. We can do this by writing on and on in the overflow buffer in the _IO_wstrnfile structure. */ _IO_wstrnfile *snf = (_IO_wstrnfile *) fp; if (fp-\u0026gt;_wide_data-\u0026gt;_IO_buf_base != snf-\u0026gt;overflow_buf) { _IO_wsetb (fp, snf-\u0026gt;overflow_buf, snf-\u0026gt;overflow_buf + (sizeof (snf-\u0026gt;overflow_buf) / sizeof (wchar_t)), 0); fp-\u0026gt;_wide_data-\u0026gt;_IO_write_base = snf-\u0026gt;overflow_buf; fp-\u0026gt;_wide_data-\u0026gt;_IO_read_base = snf-\u0026gt;overflow_buf; fp-\u0026gt;_wide_data-\u0026gt;_IO_read_ptr = snf-\u0026gt;overflow_buf; fp-\u0026gt;_wide_data-\u0026gt;_IO_read_end = (snf-\u0026gt;overflow_buf + (sizeof (snf-\u0026gt;overflow_buf) / sizeof (wchar_t))); } fp-\u0026gt;_wide_data-\u0026gt;_IO_write_ptr = snf-\u0026gt;overflow_buf; fp-\u0026gt;_wide_data-\u0026gt;_IO_write_end = snf-\u0026gt;overflow_buf; /* Since we are not really interested in storing the characters which do not fit in the buffer we simply ignore it. */ return c; } 比如修改 tcache 变量、mp_结构体、pointer_guard 变量等。\n修改成功后，再使用其他技术控制程序执行流。\n相关技巧 house of apple1 是对现有一些 IO 流攻击方法的补充，能在一次劫持 IO 流的过程中做到任意地址写已知值，进而构造出其他方法攻击成功的条件。\n利用效果 任意地址写已知堆地址 2.26-House of Apple2 漏洞成因 堆溢出\n适用范围 2.23—— 至今 已知 heap 地址和 glibc 地址 能控制程序执行 IO 操作，包括但不限于：从 main 函数返回、调用 exit 函数、通过__malloc_assert 触发 能控制_IO_FILE 的 vtable 和_wide_data，一般使用 largebin attack 去控制 利用原理 _IO_WIDE_JUMPS 没有检查_wide_vtable 的合法性：\n1 2 3 4 5 6 7 8 #define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-\u0026gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-\u0026gt;_wide_vtable 所以利用_IO_wfile_jumps 等伪造_wide_vtable 即可。\n相关技巧 利用_IO_wfile_overflow 函数控制程序执行流时对 fp 的设置如下：\n_flags 设置为 ~(2 | 0x8 | 0x800)，如果不需要控制 rdi，设置为 0 即可；如果需要获得 shell，可设置为 sh;，注意前面有两个空格 vtable 设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap 地址（加减偏移），使其能成功调用_IO_wfile_overflow 即可 _wide_data 设置为可控堆地址 A，即满足 *(fp + 0xa0) = A _wide_data-\u0026gt;_IO_write_base 设置为 0，即满足 *(A + 0x18) = 0 _wide_data-\u0026gt;_IO_buf_base 设置为 0，即满足 *(A + 0x30) = 0 _wide_data-\u0026gt;_wide_vtable 设置为可控堆地址 B，即满足 *(A + 0xe0) = B _wide_data-\u0026gt;_wide_vtable-\u0026gt;doallocate 设置为地址 C 用于劫持 RIP，即满足 *(B + 0x68) = C 利用效果 任意函数执行 2.27-House of Apple3 漏洞成因 堆溢出\n适用范围 2.23—— 至今 已知 heap 地址和 glibc 地址 能控制程序执行 IO 操作，包括但不限于：从 main 函数返回、调用 exit 函数、通过__malloc_assert 触发 能控制_IO_FILE 的 vtable 和_wide_data，一般使用 largebin attack 去控制 利用原理 __libio_codecvt_in 等函数，可以设置 gs-\u0026gt;__shlib_handle == NULL 绕过 PTR_DEMANGLE 对指针的保护，然后通过_IO_wfile_underflow 调用到__libio_codecvt_in 来控制函数指针，执行任意代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 enum __codecvt_result __libio_codecvt_in (struct _IO_codecvt *codecvt, __mbstate_t *statep, const char *from_start, const char *from_end, const char **from_stop, wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop) { enum __codecvt_result result; // gs 源自第一个参数 struct __gconv_step *gs = codecvt-\u0026gt;__cd_in.step; int status; size_t dummy; const unsigned char *from_start_copy = (unsigned char *) from_start; codecvt-\u0026gt;__cd_in.step_data.__outbuf = (unsigned char *) to_start; codecvt-\u0026gt;__cd_in.step_data.__outbufend = (unsigned char *) to_end; codecvt-\u0026gt;__cd_in.step_data.__statep = statep; __gconv_fct fct = gs-\u0026gt;__fct; #ifdef PTR_DEMANGLE // 如果gs-\u0026gt;__shlib_handle不为空，则会用__pointer_guard去解密 // 这里如果可控，设置为NULL即可绕过解密 if (gs-\u0026gt;__shlib_handle != NULL) PTR_DEMANGLE (fct); #endif // 这里有函数指针调用 // 这个宏就是调用fct(gs, ...) status = DL_CALL_FCT (fct, (gs, \u0026amp;codecvt-\u0026gt;__cd_in.step_data, \u0026amp;from_start_copy, (const unsigned char *) from_end, NULL, \u0026amp;dummy, 0, 0)); // ...... } 相关技巧 利用_IO_wfile_underflow 函数控制程序执行流时对 fp 的设置如下：\n_flags 设置为 ~(4 | 0x10) vtable 设置为_IO_wfile_jumps 地址（加减偏移），使其能成功调用_IO_wfile_underflow 即可 fp-\u0026gt;_IO_read_ptr \u0026lt; fp-\u0026gt;_IO_read_end，即满足 *(fp + 8) \u0026lt; *(fp + 0x10) _wide_data 保持默认，或者设置为堆地址，假设其地址为 A，即满足 *(fp + 0xa0) = A _wide_data-\u0026gt;_IO_read_ptr \u0026gt;= _wide_data-\u0026gt;_IO_read_end，即满足 *A \u0026gt;= *(A + 8) _codecvt 设置为可控堆地址 B，即满足 *(fp + 0x98) = B codecvt-\u0026gt;__cd_in.step 设置为可控堆地址 C，即满足 *B = C codecvt-\u0026gt;__cd_in.step-\u0026gt;__shlib_handle 设置为 0，即满足 *C = 0 codecvt-\u0026gt;__cd_in.step-\u0026gt;__fct 设置为地址 D, 地址 D 用于控制 rip，即满足 *(C + 0x28) = D。当调用到 D 的时候，此时的 rdi 为 C。如果_wide_data 也可控的话，rsi 也能控制。 利用效果 任意函数执行 2.28-House of Gods 漏洞成因 堆溢出\n适用范围 2.23——2.27 泄露堆地址和 libc 地址 任意大小分配 利用原理 这个技巧比较有意思，非常建议把作者的原博客读一下。我会简述一下该技巧的利用过程。\n总的来说，该技巧最终的目的是伪造一个 fake arena，通过劫持 main_arena.next 字段完成。\n其主要过程为：\n通过 binmap 的赋值，将其当做 chunk 的 size，然后修改 unsortedbin 链的 bk 指向 binmap，作者选择的是 0x90 大小的 chunk，释放后恰好让 binmap 称为 0x200，然后 binmap-\u0026gt;bk 是 main_arena(初始状态下 main_arena.next = \u0026amp;main_arena)，然后 main_arena-\u0026gt;bk= fastbin[0x40] 分配 0x1f0 大小的 chunk 就刚好能分配到 binmap 之后修改掉 main_arena 的 system_mem 为很大的值和 next 指向 fake arena 然后用 unsortedbin attack 打掉 narenas，将其改为一个很大的数 然后分配两次 malloc(0xffffffffffffffbf + 1)，触发 arena_get_retry，进而触发两次 reused_arena，就能把 fake arena 给 thread_arena 变量 最后直接伪造 fastbin 任意地址分配 相关技巧 仅仅借助 unsortedbin 链就能控制 main_arena 的 next 和 system_mem 利用 binmap 的值构造出合法的 size 利用效果 劫持 thread_arena 为 fake_arena 2.29-House of Lys 漏洞成因 堆溢出\n适用范围 2.23 —— 至今 泄露堆地址和 libc 地址 任意大小分配 利用原理 调用 _IO_obstack_XXX 函数的时候，没有检查函数指针的有效性。调用链为：\n1 2 3 4 5 6 7 8 9 10 exit __run_exit_handlers fcloseall _IO_cleanup _IO_flush_all_lockp _IO_obstack_xsputn obstack_grow _obstack_newchunk CALL_CHUNKFUN(一个宏定义) (*(h)-\u0026gt;chunkfun)((h)-\u0026gt;extra_arg, (size)) 3 - 总结 总结了 30 种 house of 系列利用手法 给出了每种利用手法的影响版本、适用范围、利用原理等 所有的利用方法都可以在源码中找到答案，因此强烈建议将源码反复阅读 可以根据目前已有的技术提出新的组合技 ","date":"0001-01-01T00:00:00Z","permalink":"https://A1ester.github.io/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87-hugo-%E6%96%87%E7%AB%A0/","title":"我的第一篇 Hugo 文章"}]
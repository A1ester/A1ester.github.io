<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="[0xC40 , 0xE00) 97 [0xE00 , 0x1000) 98 [0x1000 , 0x1200) 99 [0x1200 , 0x1400) 100 [0x1400 , 0x1600) 101 等差 0x200 … [0x2800 , 0x2A00) 111 [0x2A00 , 0x3000) 112 [0x3000 , 0x4000) 113 [0x4000 , 0x5000) 114 等差 0x1000 … [0x9000 , 0xA000) 119 [0xA000 , 0x10000) 120 [0x10000 , 0x18000) 121 [0x18000 , 0x20000) 122 [0x20000 , 0x28000) 123 [0x28000 , 0x40000) 124 [0x40000 ,">
<title>我的第一篇 Hugo 文章</title>

<link rel='canonical' href='https://A1ester.github.io/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87-hugo-%E6%96%87%E7%AB%A0/'>

<link rel="stylesheet" href="/scss/style.min.915a5be3ed3d9e32f52e68aadaacbf8cd2d00a00952f920ed84eaa628eb32562.css"><meta property='og:title' content="我的第一篇 Hugo 文章">
<meta property='og:description' content="[0xC40 , 0xE00) 97 [0xE00 , 0x1000) 98 [0x1000 , 0x1200) 99 [0x1200 , 0x1400) 100 [0x1400 , 0x1600) 101 等差 0x200 … [0x2800 , 0x2A00) 111 [0x2A00 , 0x3000) 112 [0x3000 , 0x4000) 113 [0x4000 , 0x5000) 114 等差 0x1000 … [0x9000 , 0xA000) 119 [0xA000 , 0x10000) 120 [0x10000 , 0x18000) 121 [0x18000 , 0x20000) 122 [0x20000 , 0x28000) 123 [0x28000 , 0x40000) 124 [0x40000 ,">
<meta property='og:url' content='https://A1ester.github.io/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87-hugo-%E6%96%87%E7%AB%A0/'>
<meta property='og:site_name' content='A1ester'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' />
<meta name="twitter:title" content="我的第一篇 Hugo 文章">
<meta name="twitter:description" content="[0xC40 , 0xE00) 97 [0xE00 , 0x1000) 98 [0x1000 , 0x1200) 99 [0x1200 , 0x1400) 100 [0x1400 , 0x1600) 101 等差 0x200 … [0x2800 , 0x2A00) 111 [0x2A00 , 0x3000) 112 [0x3000 , 0x4000) 113 [0x4000 , 0x5000) 114 等差 0x1000 … [0x9000 , 0xA000) 119 [0xA000 , 0x10000) 120 [0x10000 , 0x18000) 121 [0x18000 , 0x20000) 122 [0x20000 , 0x28000) 123 [0x28000 , 0x40000) 124 [0x40000 ,">
    <link rel="shortcut icon" href="/favicon.ico" />

  

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu13739649187745961479.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🥱</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">A1ester</a></h1>
            <h2 class="site-description">欢迎来到我的博客</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E9%93%BE/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友链</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#0xc40--0xe00--------97">[0xC40 , 0xE00)        97</a></li>
    <li><a href="#0x2800--0x2a00------111">[0xE00 , 0x1000)       98
[0x1000 , 0x1200)      99
[0x1200 , 0x1400)      100
[0x1400 , 0x1600)      101
等差 0x200    …
[0x2800 , 0x2A00)      111</a></li>
    <li><a href="#0x2a00--0x3000------112">[0x2A00 , 0x3000)      112</a></li>
    <li><a href="#0x9000--0xa000------119">[0x3000 , 0x4000)      113
[0x4000 , 0x5000)      114
等差 0x1000    …
[0x9000 , 0xA000)      119</a>
      <ol>
        <li><a href="#use-after-free-uaf">Use-After-Free (UAF)</a></li>
        <li><a href="#off-by-one">off by one</a></li>
        <li><a href="#unsafe-unlink">unsafe unlink</a></li>
        <li><a href="#unsorted-bin-attack">unsorted bin attack</a></li>
        <li><a href="#large-bin-attack">large bin attack</a></li>
      </ol>
    </li>
    <li><a href="#2-house-of-系列">2-House Of 系列</a></li>
    <li><a href="#21-house-of-spirit">2.1-House of Spirit</a>
      <ol>
        <li><a href="#漏洞成因">漏洞成因</a></li>
        <li><a href="#适用范围">适用范围</a></li>
        <li><a href="#利用原理">利用原理</a></li>
        <li><a href="#相关技巧">相关技巧</a></li>
        <li><a href="#利用效果">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#22-house-of-einherjar">2.2-House of Einherjar</a>
      <ol>
        <li><a href="#漏洞成因-1">漏洞成因</a></li>
        <li><a href="#适用范围-1">适用范围</a></li>
        <li><a href="#利用原理-1">利用原理</a></li>
        <li><a href="#相关技巧-1">相关技巧</a></li>
        <li><a href="#利用效果-1">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#23-house-of-force">2.3-House of Force</a>
      <ol>
        <li><a href="#漏洞成因-2">漏洞成因</a></li>
        <li><a href="#适用范围-2">适用范围</a></li>
        <li><a href="#利用原理-2">利用原理</a></li>
        <li><a href="#相关技巧-2">相关技巧</a></li>
        <li><a href="#利用效果-2">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#24-house-of-lore">2.4-House of Lore</a>
      <ol>
        <li><a href="#漏洞成因-3">漏洞成因</a></li>
        <li><a href="#适用范围-3">适用范围</a></li>
        <li><a href="#利用原理-3">利用原理</a></li>
        <li><a href="#相关技巧-3">相关技巧</a></li>
        <li><a href="#利用效果-3">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#25-house-of-orange">2.5-House of Orange</a>
      <ol>
        <li><a href="#漏洞成因-4">漏洞成因</a></li>
        <li><a href="#适用范围-4">适用范围</a></li>
        <li><a href="#利用原理-4">利用原理</a></li>
        <li><a href="#相关技巧-4">相关技巧</a></li>
        <li><a href="#利用效果-4">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#26-house-of-rabbit">2.6-House of Rabbit</a>
      <ol>
        <li>
          <ol>
            <li><a href="#house-of-rabbit是利用malloc_consolidate合并机制的一种方法"><code>house of rabbit</code>是利用<code>malloc_consolidate()</code>合并机制的一种方法。</a></li>
          </ol>
        </li>
        <li><a href="#漏洞成因-5">漏洞成因</a></li>
        <li><a href="#适用范围-5">适用范围</a></li>
        <li><a href="#利用原理-5">利用原理</a></li>
        <li><a href="#相关技巧-5">相关技巧</a></li>
        <li><a href="#利用效果-5">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#27-house-of-roman">2.7-House of Roman</a>
      <ol>
        <li><a href="#漏洞成因-6">漏洞成因</a></li>
        <li><a href="#适用范围-6">适用范围</a></li>
        <li><a href="#利用原理-6">利用原理</a></li>
        <li><a href="#相关技巧-6">相关技巧</a></li>
        <li><a href="#利用效果-6">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#28-house-of-storm">2.8-House of Storm</a>
      <ol>
        <li><a href="#漏洞成因-7">漏洞成因</a></li>
        <li><a href="#适用范围-7">适用范围</a></li>
        <li><a href="#利用原理-7">利用原理</a></li>
        <li><a href="#相关技巧-7">相关技巧</a></li>
        <li><a href="#利用效果-7">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#29-house-of-corrosion">2.9-House of Corrosion</a>
      <ol>
        <li><a href="#漏洞成因-8">漏洞成因</a></li>
        <li><a href="#适用范围-8">适用范围</a></li>
        <li><a href="#利用原理-8">利用原理</a></li>
        <li><a href="#相关技巧-8">相关技巧</a></li>
        <li><a href="#利用效果-8">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#210-house-of-husk">2.10-House of Husk</a>
      <ol>
        <li><a href="#漏洞成因-9">漏洞成因</a></li>
        <li><a href="#适用范围-9">适用范围</a></li>
        <li><a href="#利用原理-9">利用原理</a></li>
        <li><a href="#相关技巧-9">相关技巧</a></li>
        <li><a href="#利用效果-9">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#211-house-of-atum">2.11-House of Atum</a>
      <ol>
        <li><a href="#漏洞成因-10">漏洞成因</a></li>
        <li><a href="#适用范围-10">适用范围</a></li>
        <li><a href="#利用原理-10">利用原理</a></li>
        <li><a href="#相关技巧-10">相关技巧</a></li>
        <li><a href="#利用效果-10">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#212-house-of-kauri">2.12-House of Kauri</a>
      <ol>
        <li><a href="#漏洞成因-11">漏洞成因</a></li>
        <li><a href="#适用范围-11">适用范围</a></li>
        <li><a href="#利用原理-11">利用原理</a></li>
        <li><a href="#相关技巧-11">相关技巧</a></li>
        <li><a href="#利用效果-11">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#213-house-of-fun">2.13-House of Fun</a>
      <ol>
        <li><a href="#漏洞成因-12">漏洞成因</a></li>
        <li><a href="#适用范围-12">适用范围</a></li>
        <li><a href="#利用原理-12">利用原理</a></li>
        <li><a href="#相关技巧-12">相关技巧</a></li>
        <li><a href="#利用效果-12">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#214-house-of-mind">2.14-House of Mind</a>
      <ol>
        <li><a href="#漏洞成因-13">漏洞成因</a></li>
        <li><a href="#适用范围-13">适用范围</a></li>
        <li><a href="#利用原理-13">利用原理</a></li>
        <li><a href="#相关技巧-13">相关技巧</a></li>
        <li><a href="#利用效果-13">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#215-house-of-muney">2.15-House of Muney</a>
      <ol>
        <li><a href="#漏洞成因-14">漏洞成因</a></li>
        <li><a href="#适用范围-14">适用范围</a></li>
        <li><a href="#利用原理-14">利用原理</a></li>
        <li><a href="#相关技巧-14">相关技巧</a></li>
        <li><a href="#利用效果-14">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#216-house-of-botcake">2.16-House of Botcake</a>
      <ol>
        <li><a href="#漏洞成因-15">漏洞成因</a></li>
        <li><a href="#适用范围-15">适用范围</a></li>
        <li><a href="#利用原理-15">利用原理</a></li>
        <li><a href="#相关技巧-15">相关技巧</a></li>
        <li><a href="#利用效果-15">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#217-house-of-rust">2.17-House of Rust</a>
      <ol>
        <li><a href="#漏洞成因-16">漏洞成因</a></li>
        <li><a href="#适用范围-16">适用范围</a></li>
        <li><a href="#利用原理-16">利用原理</a></li>
        <li><a href="#相关技巧-16">相关技巧</a></li>
        <li><a href="#利用效果-16">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#218-house-of-crust">2.18-House of Crust</a>
      <ol>
        <li><a href="#漏洞成因-17">漏洞成因</a></li>
        <li><a href="#适用范围-17">适用范围</a></li>
        <li><a href="#利用原理-17">利用原理</a></li>
        <li><a href="#相关技巧-17">相关技巧</a></li>
      </ol>
    </li>
    <li><a href="#219-house-of-io">2.19-House of Io</a>
      <ol>
        <li><a href="#漏洞成因-18">漏洞成因</a></li>
        <li><a href="#适用范围-18">适用范围</a></li>
        <li><a href="#利用原理-18">利用原理</a></li>
        <li><a href="#相关技巧-18">相关技巧</a></li>
        <li><a href="#利用效果-17">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#220-house-of-banana">2.20-House of Banana</a>
      <ol>
        <li><a href="#漏洞成因-19">漏洞成因</a></li>
        <li><a href="#适用范围-19">适用范围</a></li>
        <li><a href="#利用原理-19">利用原理</a></li>
        <li><a href="#相关技巧-19">相关技巧</a></li>
        <li><a href="#利用效果-18">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#221-house-of-kiwi">2.21-House of Kiwi</a>
      <ol>
        <li><a href="#漏洞成因-20">漏洞成因</a></li>
        <li><a href="#适用范围-20">适用范围</a></li>
        <li><a href="#利用原理-20">利用原理</a></li>
        <li><a href="#相关技巧-20">相关技巧</a></li>
        <li><a href="#利用效果-19">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#222-house-of-emma">2.22-House of Emma</a>
      <ol>
        <li><a href="#漏洞成因-21">漏洞成因</a></li>
        <li><a href="#适用范围-21">适用范围</a></li>
        <li><a href="#利用原理-21">利用原理</a></li>
        <li><a href="#相关技巧-21">相关技巧</a></li>
        <li><a href="#利用效果-20">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#223-house-of-pig">2.23-House of Pig</a>
      <ol>
        <li><a href="#漏洞成因-22">漏洞成因</a></li>
        <li><a href="#适用范围-22">适用范围</a></li>
        <li><a href="#利用原理-22">利用原理</a></li>
        <li><a href="#相关技巧-22">相关技巧</a></li>
        <li><a href="#利用效果-21">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#224-house-of-obstack">2.24-House of Obstack</a>
      <ol>
        <li><a href="#漏洞成因-23">漏洞成因</a></li>
        <li><a href="#适用范围-23">适用范围</a></li>
        <li><a href="#利用原理-23">利用原理</a></li>
        <li><a href="#相关技巧-23">相关技巧</a></li>
        <li><a href="#利用效果-22">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#225-house-of-apple1">2.25-House of Apple1</a>
      <ol>
        <li><a href="#漏洞成因-24">漏洞成因</a></li>
        <li><a href="#适用范围-24">适用范围</a></li>
        <li><a href="#利用原理-24">利用原理</a></li>
        <li><a href="#相关技巧-24">相关技巧</a></li>
        <li><a href="#利用效果-23">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#226-house-of-apple2">2.26-House of Apple2</a>
      <ol>
        <li><a href="#漏洞成因-25">漏洞成因</a></li>
        <li><a href="#适用范围-25">适用范围</a></li>
        <li><a href="#利用原理-25">利用原理</a></li>
        <li><a href="#相关技巧-25">相关技巧</a></li>
        <li><a href="#利用效果-24">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#227-house-of-apple3">2.27-House of Apple3</a>
      <ol>
        <li><a href="#漏洞成因-26">漏洞成因</a></li>
        <li><a href="#适用范围-26">适用范围</a></li>
        <li><a href="#利用原理-26">利用原理</a></li>
        <li><a href="#相关技巧-26">相关技巧</a></li>
        <li><a href="#利用效果-25">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#228-house-of-gods">2.28-House of Gods</a>
      <ol>
        <li><a href="#漏洞成因-27">漏洞成因</a></li>
        <li><a href="#适用范围-27">适用范围</a></li>
        <li><a href="#利用原理-27">利用原理</a></li>
        <li><a href="#相关技巧-27">相关技巧</a></li>
        <li><a href="#利用效果-26">利用效果</a></li>
      </ol>
    </li>
    <li><a href="#229-house-of-lys">2.29-House of Lys</a>
      <ol>
        <li><a href="#漏洞成因-28">漏洞成因</a></li>
        <li><a href="#适用范围-28">适用范围</a></li>
        <li><a href="#利用原理-28">利用原理</a></li>
      </ol>
    </li>
    <li><a href="#3---总结">3 - 总结</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87-hugo-%E6%96%87%E7%AB%A0/">我的第一篇 Hugo 文章</a>
        </h2>
    
        
    </div>

    
    
    
    

    
</div>

</header>

    <section class="article-content">
    
    
    <hr>
<h2 id="0xc40--0xe00--------97">[0xC40 , 0xE00)        97
</h2><h2 id="0x2800--0x2a00------111">[0xE00 , 0x1000)       98
[0x1000 , 0x1200)      99
[0x1200 , 0x1400)      100
[0x1400 , 0x1600)      101
等差 0x200    …
[0x2800 , 0x2A00)      111
</h2><h2 id="0x2a00--0x3000------112">[0x2A00 , 0x3000)      112
</h2><h2 id="0x9000--0xa000------119">[0x3000 , 0x4000)      113
[0x4000 , 0x5000)      114
等差 0x1000    …
[0x9000 , 0xA000)      119
</h2><p>[0xA000 , 0x10000)     120
[0x10000 , 0x18000)    121
[0x18000 , 0x20000)    122
[0x20000 , 0x28000)    123
[0x28000 , 0x40000)    124
[0x40000 , 0x80000)    125
[0x80000 , …. )        126</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">5</span><span class="p">.</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="err">单链表，</span><span class="o">`</span><span class="n">LIFO</span><span class="o">`</span><span class="err">（后进先出），每个</span><span class="o">`</span><span class="n">bin</span><span class="o">`</span><span class="err">内存放的堆块大小相同，且最多存放</span><span class="o">`</span><span class="mi">7</span><span class="o">`</span><span class="err">个，大小从</span><span class="o">`</span><span class="mi">24</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="mi">1032</span><span class="o">`</span><span class="err">个字节，用于存放</span><span class="o">`</span><span class="n">non</span><span class="o">-</span><span class="n">large</span><span class="o">`</span><span class="err">的</span><span class="o">`</span><span class="n">chunk</span><span class="o">`</span><span class="err">。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">`</span><span class="n">tcache_perthread_struct</span><span class="o">`</span><span class="err">本身也是一个堆块，大小为</span><span class="o">`</span><span class="mi">0</span><span class="n">x250</span><span class="o">`</span><span class="err">，位于堆开头的位置，包含数组</span><span class="o">`</span><span class="n">counts</span><span class="o">`</span><span class="err">存放每个</span><span class="o">`</span><span class="n">bin</span><span class="o">`</span><span class="err">中的</span><span class="o">`</span><span class="n">chunk</span><span class="o">`</span><span class="err">当前数量，以及数组</span><span class="o">`</span><span class="n">entries</span><span class="o">`</span><span class="err">存放</span><span class="o">`</span><span class="mi">64</span><span class="o">`</span><span class="err">个</span><span class="o">`</span><span class="n">bin</span><span class="o">`</span><span class="err">的首地址（可以通过</span><span class="o">**</span><span class="err">劫持此堆块</span><span class="o">**</span><span class="err">进行攻击）。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="err">在释放堆块时，在放入</span><span class="o">`</span><span class="n">fast</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">之前，若</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">中对应的</span><span class="o">`</span><span class="n">bin</span><span class="o">`</span><span class="err">未满，则先放入</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">中。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="err">从</span><span class="o">`</span><span class="n">fast</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">返回了一个</span><span class="o">`</span><span class="n">chunk</span><span class="o">`</span><span class="err">，则单链表中剩下的堆块会被放入对应的</span><span class="o">`</span><span class="n">tcache</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">中，直到上限。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">从</span><span class="o">`</span><span class="n">small</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">返回了一个</span><span class="o">`</span><span class="n">chunk</span><span class="o">`</span><span class="err">，则双链表中剩下的堆块会被放入对应的</span><span class="o">`</span><span class="n">tcache</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">中，直到上限。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">在将剩余堆块从</span><span class="o">`</span><span class="n">small</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">放入</span><span class="o">`</span><span class="n">tcache</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">的过程中，除了检测了第一个堆块的</span><span class="o">`</span><span class="n">fd</span><span class="o">`</span><span class="err">指针，都缺失了</span><span class="o">`</span><span class="nf">__glibc_unlikely</span><span class="w"> </span><span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">victim</span><span class="p">)</span><span class="o">`</span><span class="err">的双向链表完整性检测。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">`</span><span class="n">binning</span><span class="w"> </span><span class="n">code</span><span class="o">`</span><span class="err">，如在遍历</span><span class="o">`</span><span class="n">unsorted</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">时，每一个符合要求的</span><span class="o">`</span><span class="n">chunk</span><span class="o">`</span><span class="err">都会优先被放入</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">，然后继续遍历，除非</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">已经装满，则直接返回，不然就在遍历结束后，若找到了符合要求的大小，则把</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">中对应大小的返回一个。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="err">在</span><span class="o">`</span><span class="nf">__libc_malloc</span><span class="p">()</span><span class="o">`</span><span class="err">调用</span><span class="o">`</span><span class="nf">__int_malloc</span><span class="p">()</span><span class="o">`</span><span class="err">之前，如果</span><span class="o">`</span><span class="n">tcache</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">中有符合要求的</span><span class="o">`</span><span class="n">chunk</span><span class="o">`</span><span class="err">就直接将其返回。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">`</span><span class="n">CVE</span><span class="o">-</span><span class="mi">2017</span><span class="o">-</span><span class="mi">17426</span><span class="o">`</span><span class="err">是</span><span class="o">`</span><span class="n">libc</span><span class="o">-</span><span class="mi">2</span><span class="p">.</span><span class="mi">26</span><span class="o">`</span><span class="err">存在的漏洞，</span><span class="o">`</span><span class="n">libc</span><span class="o">-</span><span class="mi">2</span><span class="p">.</span><span class="mi">27</span><span class="o">`</span><span class="err">已经修复。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="err">可将</span><span class="o">`</span><span class="n">tcache_count</span><span class="o">`</span><span class="err">整型溢出为</span><span class="o">`</span><span class="mi">0</span><span class="n">xff</span><span class="o">`</span><span class="err">以绕过</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">，直接放入</span><span class="o">`</span><span class="n">unsorted</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">等，但在</span><span class="o">`</span><span class="n">libc</span><span class="o">-</span><span class="mi">2</span><span class="p">.</span><span class="mi">28</span><span class="o">`</span><span class="err">中，检测了</span><span class="o">`</span><span class="n">counts</span><span class="o">`</span><span class="err">溢出变成负数（</span><span class="o">`</span><span class="mi">0</span><span class="n">x00</span><span class="o">-</span><span class="mi">1</span><span class="o">=</span><span class="mi">0</span><span class="n">xff</span><span class="o">`</span><span class="err">）的情况，且增加了对</span><span class="o">`</span><span class="kt">double</span><span class="w"> </span><span class="n">free</span><span class="o">`</span><span class="err">的检查。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">`</span><span class="nf">calloc</span><span class="p">()</span><span class="o">`</span><span class="err">越过</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">取</span><span class="o">`</span><span class="n">chunk</span><span class="o">`</span><span class="err">，通过</span><span class="o">`</span><span class="nf">calloc</span><span class="p">()</span><span class="o">`</span><span class="err">分配的堆块会</span><span class="o">**</span><span class="err">清零</span><span class="o">**</span><span class="err">。</span><span class="o">**</span><span class="err">补充：</span><span class="o">**`</span><span class="nf">realloc</span><span class="p">()</span><span class="o">`</span><span class="err">的特殊用法：</span><span class="o">`</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="o">`</span><span class="err">时，等同于</span><span class="o">`</span><span class="n">free</span><span class="o">`</span><span class="err">；</span><span class="o">`</span><span class="n">realloc_ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">`</span><span class="w"> </span><span class="err">时等同于</span><span class="o">`</span><span class="n">malloc</span><span class="o">`</span><span class="err">。如果当前连续内存块足够</span><span class="o">`</span><span class="n">realloc</span><span class="o">`</span><span class="err">的话，只是将</span><span class="o">`</span><span class="n">p</span><span class="o">`</span><span class="err">所指向的空间扩大，并返回</span><span class="o">`</span><span class="n">p</span><span class="o">`</span><span class="err">的指针地址；如果当前连续内存块不够，则再找一个足够大的地方，分配一块新的内存</span><span class="o">`</span><span class="n">q</span><span class="o">`</span><span class="err">，并将</span><span class="o">`</span><span class="n">p</span><span class="o">`</span><span class="err">指向的内容</span><span class="o">`</span><span class="n">copy</span><span class="o">`</span><span class="err">到</span><span class="o">`</span><span class="n">q</span><span class="o">`</span><span class="err">，返回</span><span class="w"> </span><span class="o">`</span><span class="n">q</span><span class="o">`</span><span class="err">。并将</span><span class="o">`</span><span class="n">p</span><span class="o">`</span><span class="err">所指向的内存空间</span><span class="o">`</span><span class="n">free</span><span class="o">`</span><span class="err">；若是通过</span><span class="o">`</span><span class="n">realloc</span><span class="o">`</span><span class="err">缩小堆块，则返回的指针</span><span class="o">`</span><span class="n">p</span><span class="o">`</span><span class="err">不变，但原先相比缩小后多余的那部分将会被</span><span class="o">`</span><span class="n">free</span><span class="o">`</span><span class="err">掉。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">6</span><span class="p">.</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">除了</span><span class="o">`</span><span class="n">house</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">force</span><span class="o">`</span><span class="err">外，其实对于</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">还有一些利用点。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">当申请的</span><span class="o">`</span><span class="n">size</span><span class="o">`</span><span class="err">不大于</span><span class="o">`</span><span class="n">mmap</span><span class="o">`</span><span class="err">的阈值，但</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">当前的大小又不足以分配，则会扩展</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">，然后从新</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">里进行分配。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">这里的扩展</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">，其实不一定会直接扩展原先的</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">，可能会先将原先的</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">给</span><span class="o">`</span><span class="n">free</span><span class="o">`</span><span class="err">掉，再在之后开辟一段新区域作为新的</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">具体是，如果</span><span class="o">`</span><span class="n">brk</span><span class="o">`</span><span class="err">等于该不够大小的</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">（被记作</span><span class="o">`</span><span class="n">old_top_chunk</span><span class="o">`</span><span class="err">）的</span><span class="o">`</span><span class="n">end</span><span class="o">`</span><span class="err">位置（</span><span class="o">`</span><span class="n">old_end</span><span class="o">`</span><span class="err">，等于</span><span class="o">`</span><span class="n">old_top</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">old_size</span><span class="o">`</span><span class="err">），即</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">的</span><span class="o">`</span><span class="n">size</span><span class="o">`</span><span class="err">并没有被修改，完全是自然地分配堆块，导致了</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">不够用，则会从</span><span class="o">`</span><span class="n">old_top</span><span class="o">`</span><span class="err">处开辟更大的一块空间作为新的</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">，也就是将原先的</span><span class="o">`</span><span class="n">old_top_chunk</span><span class="o">`</span><span class="err">进行扩展了，此时没有</span><span class="o">`</span><span class="n">free</span><span class="o">`</span><span class="err">，且</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">的起始位置也没有改变，但是如果</span><span class="o">`</span><span class="n">brk</span><span class="o">`</span><span class="err">不等于</span><span class="o">`</span><span class="n">old_end</span><span class="o">`</span><span class="err">，则会先</span><span class="o">`</span><span class="n">free</span><span class="o">`</span><span class="err">掉</span><span class="o">`</span><span class="n">old_top_chunk</span><span class="o">`</span><span class="err">，再从</span><span class="o">`</span><span class="n">brk</span><span class="o">`</span><span class="err">处开辟一片空间作为</span><span class="o">`</span><span class="n">new_top_chunk</span><span class="o">`</span><span class="err">，此时的</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">头部位置变为了原先的</span><span class="o">`</span><span class="n">brk</span><span class="o">`</span><span class="err">，而如今的</span><span class="o">`</span><span class="n">brk</span><span class="o">`</span><span class="err">也做了相应的扩展，并且</span><span class="o">`</span><span class="n">unsorted</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">或</span><span class="o">`</span><span class="n">tcache</span><span class="o">`</span><span class="err">中（一般修改的大小都至少会是</span><span class="o">`</span><span class="n">small</span><span class="w"> </span><span class="n">bin</span><span class="o">`</span><span class="err">范围，但具体在哪得分情况看）会有被</span><span class="o">`</span><span class="n">free</span><span class="o">`</span><span class="err">的</span><span class="o">`</span><span class="n">old_top_chunk</span><span class="o">`</span><span class="err">。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">因此，可以通过改小</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">的</span><span class="o">`</span><span class="n">size</span><span class="o">`</span><span class="err">，再申请大堆块，做到对旧</span><span class="o">`</span><span class="n">top</span><span class="w"> </span><span class="n">chunk</span><span class="o">`</span><span class="err">的</span><span class="o">`</span><span class="n">free</span><span class="o">`</span><span class="err">，不过修改的</span><span class="o">`</span><span class="n">size</span><span class="o">`</span><span class="err">需要绕过一些检测。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">相关源码如下：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">```</span><span class="n">C</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">old_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">old_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">chunksize</span><span class="w"> </span><span class="p">(</span><span class="n">old_top</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">old_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">chunk_at_offset</span><span class="w"> </span><span class="p">(</span><span class="n">old_top</span><span class="p">,</span><span class="w"> </span><span class="n">old_size</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">old_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_top</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">old_size</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">assert</span><span class="w"> </span><span class="p">((</span><span class="n">old_top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nf">initial_top</span><span class="w"> </span><span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">old_size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">((</span><span class="k">unsigned</span><span class="w"> </span><span class="k">long</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">old_size</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MINSIZE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="nf">prev_inuse</span><span class="w"> </span><span class="p">(</span><span class="n">old_top</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="p">((</span><span class="k">unsigned</span><span class="w"> </span><span class="k">long</span><span class="p">)</span><span class="w"> </span><span class="n">old_end</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">pagesize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>需要绕过以上的断言，主要就是要求被修改的<code>top chunk</code>的<code>size</code>的<code>prev_inuse</code>位要为<code>1</code>并且<code>old_end</code>要内存页对齐，所以就要求被修改的<code>size</code>的后三位和原先要保持一致。</p>
<h3 id="use-after-free-uaf">Use-After-Free (UAF)
</h3><p><code>free(p)</code>后未将<code>p</code>清零，若是没有其他检查的话，可能造成<code>UAF</code>漏洞。
<code>double free</code>就是利用<code>UAF</code>漏洞的经典例子。</p>
<p>1.<code>fast bin</code>的<code>double free</code>：</p>
<p>(1) <code>fast bin</code>对<code>double free</code>有检查，会检查当前的<code>chunk</code>是否与<code>fast bin</code>顶部的<code>chunk</code>相同，如果相同则报错并退出。因此，我们不能连续释放两次相同的<code>chunk</code>。
可采用如下方式在中间添加一个<code>chunk</code>便绕过检查：
释放<code>A</code>，单链表为<code>A</code>，再释放<code>B</code>，单链表为<code>B-&gt;A</code>，再释放<code>A</code>，单链表为<code>A-&gt;B-&gt;A</code>，然后申请到<code>A</code>，同时将其中内容改成任意地址（改的是<code>fd</code>指针），单链表就成了<code>B-&gt;A-&gt;X</code>，其中<code>X</code>就是任意地址，这样再依次申请<code>B</code>，<code>A</code>后，再申请一次就拿到了地址<code>X</code>，可以在地址<code>X</code>中任意读写内容。
(2) 其实，若是有<code>Edit</code>功能的话，可以有如下方式：
若当前单链表是<code>B-&gt;A</code>，将<code>B</code>的<code>fd</code>指针通过<code>Edit</code>修改为任意地址<code>X</code>，单链表就变成了<code>B-&gt;X</code>，申请了<code>B</code>之后，再申请一次，就拿到了<code>X</code>地址，从而进行读写。
需要注意的是，以上的<code>X</code>准确说是<code>fake chunk</code>的<code>chunk header</code>地址，因为<code>fast bin</code>会检测<code>chunk_header_addr + 8</code>（即<code>size</code>）是否符合当前<code>bin</code>的大小。</p>
<p>2.<code>tcache</code>的<code>double free</code>：</p>
<p><code>libc-2.28</code>之前并不会检测<code>double free</code>，因此可以连续两次释放同一个堆块进入<code>tcache</code>，并且<code>tcache</code>的<code>next</code>指针指向的是<code>user data</code>，因此不会做大小的检测。
释放<code>A</code>，单链表为<code>A</code>，再释放<code>A</code>，单链表为<code>A-&gt;A</code>，申请<code>A</code>并把其中内容（<code>next</code>指针）改成<code>X</code>，则单链表为<code>A-&gt;X</code>，再申请两次，拿到<code>X</code>地址的读写权。
在以上过程结束后，实际上是放进<code>tcache</code>了两次，而申请取出了三次，因此当前<code>tcache</code>的<code>counts</code>会变成<code>0xff</code>，整型溢出，这是一个可以利用的操作，当然若是想避免此情况，在第一次释放<code>A</code>之前，可以先释放一次<code>B</code>，将其放入此<code>tcache bin</code>即可。
此外，若是有<code>Edit</code>功能，仿照上述 <code>fast bin</code>对应操作的技术被称为<code>tcache_poisoning</code>。</p>
<p>3.<code>glibc2.31</code>下的<code>double free</code>：</p>
<p>在 <code>glibc2.29</code>之后加入了对<code>tcache</code>二次释放的检查，方法是在<code>tcache_entry</code>结构体中加入了一个标志<code>key</code>，用于表示<code>chunk</code>是否已经在所属的<code>tcache bin</code>中，对于每个<code>chunk</code>而言，<code>key</code>在其<code>bk</code>指针的位置上。
当<code>chunk</code>被放入<code>tcache bin</code>时会设置<code>key</code>指向其所属的<code>tcache</code>结构体：<code>e-&gt;key = tcache;</code>，并在<code>free</code>时，进入<code>tcache bin</code>之前，会进行检查：如果是<code>double free</code>，那么<code>put</code>时<code>key</code>字段被设置了<code>tcache</code>，就会进入循环被检查出来；如果不是，那么<code>key</code>字段就是用户数据区域，可以视为随机的，只有<code>1/(2^size_t)</code>的可能行进入循环，然后循环发现并不是<code>double free</code>。这是一个较为优秀的算法，进行了剪枝，具体源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">tcache</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">LIBC_PROBE</span><span class="p">(</span><span class="n">memory_tcache_double_free</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">tc_idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">];</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">malloc_printerr</span><span class="p">(</span><span class="s">&#34;free(): double free detected in tcache 2&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可通过<code>fast bin double free</code>+<code>tcache stash</code>机制来进行绕过：
(1) 假设目前<code>tcache</code>被填满了：<code>C6-&gt;C5-&gt;C4-&gt;C3-&gt;C2-&gt;C1-&gt;C0</code>，<code>fast bin</code>中为：<code>C7-&gt;C8-&gt;C7</code>。
(2) 下一步，为了分配到<code>fast bin</code>，需要先申请<code>7</code>个，让<code>tcache</code>为空（或<code>calloc</code>），再次申请时就会返回<code>fast bin</code>中的<code>C7</code>，同时由于<code>tcache stash</code>机制，<code>fast bin</code>中剩下的<code>C8</code>,<code>C7</code>均被放入了<code>tcache bin</code>，此时，在<code>C7</code>的<code>fd</code>字段写入<code>target_addr</code>（相当于获得了<code>Edit</code>功能），于是<code>target_addr</code>也被放入了<code>tcache bin</code>，因此这里<code>target_addr</code>处甚至不需要伪造<code>size</code>（<code>target_addr</code>指向<code>user data</code>区）。
(3) 此时，<code>tcache bin</code>中单链表为：<code>C8-&gt;C7-&gt;target_addr</code>，再申请到<code>target_addr</code>，从而得到了一个真正的任意写。
补充：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">9</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nf">malloc</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="nf">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span> <span class="c1">//free(ptr[9]);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">malloc</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码，若是按注释中的写，则在没有触发<code>tcache stash</code>机制时，<code>fast bin</code>中为<code>C9-&gt;C8-&gt;C7</code>，取走<code>C9</code>，最终<code>tcache bin</code>中是<code>C7-&gt;C8</code>，符合设想（依次取<code>C8</code>，<code>C7</code>放入<code>tcache bin</code>）。
然而，若是<code>double free chunk_7</code>，则在没有触发<code>tcache stash</code>机制时，<code>fast bin</code>中为<code>C7-&gt;C8-&gt;C7</code>，取走<code>C7</code>，最终<code>tcache bin</code>中是<code>C8-&gt;C7-&gt;C8</code>，而若是按照<code>tcache bin</code>放入的规则，应该也是类似于<code>C7-&gt;C8</code>，不符合设想。
流程如下：
(1) 取<code>C8</code>放入<code>tcache bin</code>，同时<code>REMOVE_FB (fb, pp, tc_victim);</code>会清空<code>C8</code>的<code>next(fd)</code>指针，并且将链表头设置为指向<code>C8</code>原先<code>fd</code>指针指向的堆块<code>C7</code>（源码分析如下）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define REMOVE_FB(fb, victim, pp)</span><span class="c1">//摘除一个空闲chunk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">do</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">victim</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">((</span><span class="n">pp</span> <span class="o">=</span> <span class="nf">catomic_compare_and_exchange_val_acq</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">victim</span><span class="p">))</span> <span class="o">!=</span> <span class="n">victim</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//catomic_compare_and_exchange_val_rel_acq 功能是 如果*fb等于victim，则将*fb存储为victim-&gt;fd，返回victim；
</span></span></span><span class="line"><span class="cl"><span class="c1">//其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>(2) 目前<code>fast bin</code>中为<code>C7-&gt;C8</code>（最开始取走<code>C7</code>并不清空其<code>fd</code>字段），然后根据<code>tcache bin</code>的放入规则，最终依次放入后为<code>C8-&gt;C7-&gt;C8</code>。</p>
<p>4.当可以<code>Edit</code>时，往往就不需要<code>double free</code>了，而有些情况看似不能对空闲中的堆块进行<code>Edit</code>（比如存放长度的数组在<code>free</code>后会清零），但是可以利用<code>UAF</code>漏洞对处于空闲状态的堆块进行<code>Edit</code>，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">malloc</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span> <span class="err">#</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nf">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">malloc</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span> <span class="err">#</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nf">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="err">#</span><span class="n">UAF</span>
</span></span><span class="line"><span class="cl"><span class="nf">Edit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时，我们编辑<code>chunk 2</code>，实则是在对已经<code>free</code>的<code>chunk 1</code>进行编辑。</p>
<h3 id="off-by-one">off by one
</h3><p>缓冲区溢出了一个字节，由于<code>glibc</code>的空间复用技术（即<code>pre_size</code>给上一个<code>allocated</code>的堆块使用），所以可通过<code>off by one</code>修改下一个堆块的<code>size</code>域。
经常是由于循环次数设置有误造成了该漏洞的产生。比较隐蔽的是<code>strcpy</code>会在复制过去的字符串末尾加<code>\x00</code>，可能造成<code>poison null byte</code>，例如，<code>strlen</code> 和 <code>strcpy</code> 的行为不一致可能会导致<code>off-by-one</code> 的发生：<code>strlen</code> 在计算字符串长度时是不把结束符<code>\x00</code>计算在内的，但是<code>strcpy</code>在复制字符串时会拷贝结束符 <code>\x00</code>。
<code>off by one</code>经常可以与<code>Chunk Extend and Overlapping</code>配合使用。</p>
<ol>
<li><strong>扩展被释放块：</strong> 当可溢出堆块的下一个堆块处在<code>unsorted bin</code>中，可以通过溢出单字节扩大下一个堆块的<code>size</code>域，当申请新<code>size</code>从<code>unsorted bin</code>中取出该堆块时，就会造成堆块重叠，从而控制原堆块之后的堆块。该方法的成功依赖于：<code>malloc</code>并不会对<code>free chunk</code>的完整性以及<code>next chunk</code>的<code>prev_size</code>进行检查，甚至都不会查<code>next chunk</code>的地址是不是个堆块。
<code>libc-2.29</code>增加了检测<code>next chunk</code>的<code>prev_size</code>，会报错：<code>malloc(): mismatching next-&gt;prev_size (unsorted)</code>，也增加了检测<code>next chunk</code>的地址是不是个堆块，会报错<code>malloc(): invalid next size (unsorted)</code>。
<code>libc-2.23(11)</code>的版本，当释放某一个非<code>fast bin</code>的堆块时，若上/下某堆块空闲，则会检测该空闲堆块的<code>size</code>与其<code>next chunk</code>的<code>prev_size</code>是否相等。</li>
<li><strong>扩展已分配块：</strong> 当可溢出堆块的一个堆块（通常是<code>fast bin</code>,<code>small bin</code>）处于使用状态中时，单字节溢出可修改处于<code>allocated</code>的堆块的<code>size</code>域，扩大到下面某个处于空闲状态的堆块处，然后将其释放，则会一直覆盖到下面的此空闲堆块，造成堆块重叠。
此时释放处于使用状态的堆块，由于是根据处于使用中的堆块的<code>size</code>找到下一个堆块的，而若是上一个堆块处于使用中，那么下一个堆块的<code>prev_size</code>就不会存放上一个堆块的大小，而是进行空间复用，存放上一个堆块中的数据，因此，此时不论有没有<code>size</code>与<code>next chunk</code>的<code>prev_size</code>的一致性检测，上述利用都可以成功。
同理，若将堆块大小设成<code>0x10</code>的整数倍，就不会复用空间，此时单字节溢出就可以修改<code>next chunk</code>的<code>prev_size</code>域，然后将其释放，就会与上面的更多的堆块合并，造成堆块重叠，当然此时需要<code>next chunk</code>的<code>prev_inuse</code>为零。
当加入了对当前堆块的<code>size</code>与下一个堆块的<code>prev_size</code>的比对检查后，上述利用就难以实现了。</li>
<li><strong>收缩被释放块：</strong> 利用<code>poison null byte</code>，即溢出的单字节为<code>\x00</code>的情况。通过单字节溢出可将下一个被释放块的<code>size</code>域缩小，而此被释放块的下一个堆块（<code>allocated</code>）的<code>prev_size</code>并不会被更改（将已被<code>shrink</code>的堆块进行切割，仍不会改变此<code>prev_size</code>域），若是将此被释放块的下一个堆块释放，则还是会利用原先的<code>prev_size</code>找到上一个被释放块进行合并，这样就造成了堆块重叠。
同样，当加入了对当前堆块的<code>size</code>与下一个堆块的<code>prev_size</code>的比对检查后，上述利用就难以实现了。</li>
<li><strong>house of einherjar：</strong> 同样是利用<code>poison null byte</code>，当可溢出堆块的下一个堆块处于使用中时，通过单字节溢出，可修改<code>next chunk</code>的<code>prev_inuse</code>位为零(<code>0x101-&gt;0x100</code>)，同时将<code>prev_size</code>域改为该堆块与目标堆块位置的偏移，再释放可溢出堆块的下一个堆块，则会与上面的堆块合并，造成堆块重叠。值得一提的是，<code>house of einherjar</code>不仅可以造成堆块重叠，还具备将堆块分配到任意地址的能力，只要把上述的目标堆块改为<code>fake chunk</code>的地址即可，因此通常需要泄露堆地址，或者在栈上伪造堆。</li>
</ol>
<h3 id="unsafe-unlink">unsafe unlink
</h3><p><code>unlink:</code>由经典的链表操作<code>FD=P-&gt;fd;BK=P-&gt;bk;FD-&gt;bk=BK;BK-&gt;fd=FD;</code>实现，这样堆块<code>P</code>就从该双向链表中取出了。
<code>unlink</code>中有一个保护检查机制：<code>(P-&gt;fd-&gt;bk!=P || P-&gt;bk-&gt;fd!=P) == False</code>，需要绕过。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="kt">uint64_t</span> <span class="o">*</span><span class="n">chunk0_ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">malloc_size</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="c1">//避免进入fast bin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">chunk0_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">malloc_size</span><span class="p">);</span> <span class="c1">//chunk0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//chunk0_ptr指向堆块的user data，而&amp;chunk0_ptr是指针的地址，其中存放着该指针指向的堆块的fd的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//在0x90的chunk0的user data区伪造一个大小为0x80的fake chunk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">chunk1_ptr</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">malloc_size</span><span class="p">);</span> <span class="c1">//chunk1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">chunk0_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="c1">//高版本会有(chunksize(P)!=prev_size(next_chunk(P)) == False)的检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//绕过检测((P-&gt;fd-&gt;bk!=P || P-&gt;bk-&gt;fd!=P) == False)：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">chunk0_ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">chunk0_ptr</span> <span class="o">-</span> <span class="mh">0x18</span><span class="p">;</span> <span class="c1">//设置fake chunk的fd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//P-&gt;fd-&gt;bk=*(*(P+0x10)+0x18)=*(&amp;P-0x18+0x18)=P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">chunk0_ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">chunk0_ptr</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span> <span class="c1">//设置fake chunk的bk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//P-&gt;bk-&gt;fd=*(*(P+0x18)+0x10)=*(&amp;P-0x10+0x10)=P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">chunk1_hdr</span> <span class="o">=</span> <span class="n">chunk1_ptr</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span> <span class="c1">//chunk1_hdr指向chunk1 header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">chunk1_hdr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc_size</span><span class="p">;</span> <span class="c1">//往上寻找pre(fake) chunk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">chunk1_hdr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//prev_inuse -&gt; 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="c1">//高版本需要先填满对应的tcache bin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">free</span><span class="p">(</span><span class="n">chunk1_ptr</span><span class="p">);</span> <span class="c1">//触发unlink，chunk1找到被伪造成空闲的fake chunk想与之合并，然后对fake chunk进行unlink操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//P-&gt;fd-&gt;bk=P=P-&gt;bk,P-&gt;bk-&gt;fd=P=P-&gt;fd,即最终P=*(P+0x10)=&amp;P-0x18
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">victim_string</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;AAAAAAA&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">chunk0_ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">victim_string</span><span class="p">;</span> <span class="c1">//*(P+0x18)=*(&amp;P)=P=&amp;str
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="n">chunk0_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x42424242424242LL</span><span class="p">;</span> <span class="c1">//*P=*(&amp;str)=str=BBBBBBB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;New Value: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">victim_string</span><span class="p">);</span> <span class="c1">//BBBBBBB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="unsorted-bin-attack">unsorted bin attack
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">  <span class="sb">`unsorted bin into stack`</span><span class="nx">的原理比较简单</span><span class="err">，</span><span class="nx">就是在栈上伪造一个堆块</span><span class="err">，</span><span class="nx">然后修改</span><span class="sb">`unsorted bin`</span><span class="nx">中某堆块的</span><span class="sb">`bk`</span><span class="nx">指针指向此</span><span class="sb">`fake chunk`</span><span class="err">，</span><span class="nx">通过申请到此</span><span class="sb">`fake chunk`</span><span class="nx">达到对栈上地址的读写权</span><span class="err">。</span><span class="nx">需要注意的是高版本有</span><span class="sb">`tcache`</span><span class="nx">的情况</span><span class="err">，</span><span class="nx">此时在</span><span class="sb">`unsorted bin`</span><span class="nx">中找到一个合适大小的堆块后并不会直接返回</span><span class="err">，</span><span class="nx">而是会放入</span><span class="sb">`tcache bin`</span><span class="nx">中</span><span class="err">，</span><span class="nx">直到上限</span><span class="err">，</span><span class="nx">若是某时刻</span><span class="sb">`tcache_count`</span><span class="nx">达到上限</span><span class="err">，</span><span class="nx">则直接返回该</span><span class="sb">`fake chunk`</span><span class="err">，</span><span class="nx">不然会继续遍历</span><span class="err">，</span><span class="nx">并在最后从</span><span class="sb">`tcache bin`</span><span class="nx">中取出返回给用户</span><span class="err">，</span><span class="nx">此时就要求</span><span class="sb">`fake chunk`</span><span class="nx">的</span><span class="sb">`bk`</span><span class="nx">指针指向自身</span><span class="err">，</span><span class="nx">这样就可以通过循环绕过</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">    <span class="nx">再来看真正的</span><span class="sb">`unsorted bin attack`</span><span class="err">，</span><span class="nx">其实在上述利用中</span><span class="err">，</span><span class="sb">`fake chunk`</span><span class="nx">的</span><span class="sb">`fd`</span><span class="nx">指针被修改成了</span><span class="sb">`unsorted bin`</span><span class="nx">的地址</span><span class="err">，</span><span class="nx">位于</span><span class="sb">`main_arena`</span><span class="err">，</span><span class="nx">甚至可以通过泄露其得到</span><span class="sb">`libc`</span><span class="nx">的基地址</span><span class="err">，</span><span class="nx">当然也可以通过这个利用</span><span class="err">，</span><span class="nx">将任意地址中的值改成很大的数</span><span class="err">（</span><span class="nx">如</span><span class="sb">`global_max_fast`</span><span class="err">），</span><span class="nx">这就是</span><span class="sb">`unsorted bin attack`</span><span class="nx">的核心</span><span class="err">，</span><span class="nx">其原理是</span><span class="err">：</span><span class="nx">当某堆块</span><span class="sb">`victim`</span><span class="nx">从</span><span class="sb">`unsorted bin list`</span><span class="nx">中取出时</span><span class="err">，</span><span class="nx">会进行</span><span class="sb">`bck = victim-&gt;bk; unsorted_chunks(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks(av);`</span><span class="nx">的操作</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">    <span class="nx">例如</span><span class="err">，</span><span class="nx">假设</span><span class="sb">`chunk_A`</span><span class="nx">在</span><span class="sb">`unsorted bin`</span><span class="nx">中</span><span class="err">，</span><span class="nx">此时将</span><span class="sb">`chunk_A`</span><span class="nx">的</span><span class="sb">`bk`</span><span class="nx">改成</span><span class="sb">`&amp;global_max_fast - 0x10`</span><span class="err">，</span><span class="nx">然后取出</span><span class="sb">`chunk_A`</span><span class="err">，</span><span class="nx">那么</span><span class="sb">`chunk_A-&gt;bk-&gt;fd`</span><span class="err">，</span><span class="nx">也就是</span><span class="sb">`global_max_fast`</span><span class="nx">中就会写入</span><span class="sb">`unsorted bin`</span><span class="nx">地址</span><span class="err">，</span><span class="nx">即一个很大的数</span><span class="err">。</span><span class="nx">若是在高版本有</span><span class="sb">`tcache`</span><span class="nx">的情况下</span><span class="err">，</span><span class="nx">可通过放入</span><span class="sb">`tcache`</span><span class="nx">的次数小于从中取出的次数</span><span class="err">，</span><span class="nx">从而整型溢出</span><span class="err">，</span><span class="nx">使得</span><span class="sb">`tcache_count`</span><span class="nx">为一个很大的数</span><span class="err">，</span><span class="nx">如</span><span class="sb">`0xff`</span><span class="err">，</span><span class="nx">就可以解决</span><span class="sb">`unsorted bin into stack`</span><span class="nx">中提到的</span><span class="sb">`tcache`</span><span class="nx">特性带来的问题</span><span class="err">。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="large-bin-attack">large bin attack
</h3><p>​    假设当前<code>chunk_A</code>在<code>large bin</code>中，修改其<code>bk</code>为<code>addr1 - 0x10</code>，同时修改其<code>bk_nextsize</code>为<code>addr2 - 0x20</code>，此时<code>chunk_B</code>加入了此<code>large bin</code>，其大小<strong>略大于</strong><code>chunk_A</code>，将会进行如下操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span><span class="c1">//1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span><span class="c1">//2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">bck</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span><span class="c1">//3
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>​    其中，<code>victim</code>就是<code>chunk_B</code>，而<code>fwd</code>就是修改过后的<code>chunk_A</code>，注意到<code>3</code>处<code>bck-&gt;fd = victim</code>，同时，把<code>1</code>带入<code>2</code>可得到：<code>fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim</code>，因此，最终<code>addr1</code>与<code>addr2</code>地址中的值均被赋成了<code>victim</code>即<code>chunk_B</code>的<code>chunk header</code>地址，也是一个很大的数。</p>
<h2 id="2-house-of-系列">2-House Of 系列
</h2><h2 id="21-house-of-spirit">2.1-House of Spirit
</h2><blockquote>
<p>[!NOTE]</p>
<p>对于<code>fast bin</code>，可以在栈上伪造两个<code>fake chunk</code>，但需要绕过检查，应满足第一个<code>fake chunk</code>的标志位<code>IS_MMAPPED</code>与<code>NON_MAIN_ARENA</code>均为零（<code>PREV_INUSE</code>并不影响释放），且要求其大小满足<code>fast bin</code>的大小，对于其<code>next chunk</code>，即第二个<code>fake chunk</code>，需要满足其大小大于<code>0x10</code>，小于<code>av-&gt;system_mem</code>（<code>0x21000</code>）才能绕过检查。之后，伪造指针<code>P = &amp; fake_chunk1_mem</code>，然后<code>free(P)</code>，<code>fake_chunk1</code>就进入了<code>fast bin</code>，之后再申请同样大小的内存，即可取出<code>fake_chunk1</code>，获得了栈上的任意读写权（当然并不局限于在栈上伪造）。
该技术在<code>libc-2.26</code>中仍然适用，可以对<code>tcache</code>做类似的操作，甚至没有对上述<code>next chunk</code>的检查。</p>
</blockquote>
<h3 id="漏洞成因">漏洞成因
</h3><p>堆溢出写</p>
<h3 id="适用范围">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理">利用原理
</h3><p>利用堆溢出，修改 <code>chunk size</code>，伪造出 <code>fake chunk</code>，然后通过堆的释放和排布，控制 <code>fake chunk</code>。<code>house of spirit</code> 的操作思路有很多，比如可以按如下操作进行利用：</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C、chunk D</code></li>
<li>对 <code>A</code> 写操作的时候溢出，修改 <code>B</code> 的 <code>size</code> 域，使其能包括 <code>chunk C</code></li>
<li>释放 <code>B</code>，然后把 <code>B</code> 申请回来，再释放 <code>C</code>，则可以通过读写 <code>B</code> 来控制 <code>C</code> 的内容</li>
</ul>
<h3 id="相关技巧">相关技巧
</h3><p>起初 <code>house of spirit</code> 主要是针对 <code>fastbin</code>，后来引入了 <code>tcachebin</code> 后，也可以使用 <code>tcachebin</code> 版本的 <code>house of spirit</code>。利用方法与 <code>fastbin</code> 场景下类似，注意好不同版本下的检查条件即可。</p>
<h3 id="利用效果">利用效果
</h3><ul>
<li>劫持 <code>fastbin/tcachebin</code> 的 <code>fd</code> 之后，可以任意地址分配、任意地址读写</li>
</ul>
<h2 id="22-house-of-einherjar">2.2-House of Einherjar
</h2><h3 id="漏洞成因-1">漏洞成因
</h3><p>溢出写、<code>off by one</code>、<code>off by null</code></p>
<h3 id="适用范围-1">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可分配大于处于 <code>unsortedbin</code> 的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-1">利用原理
</h3><p>利用 <code>off by null</code> 修改掉 <code>chunk</code> 的 <code>size</code> 域的 <code>P</code> 位，绕过 <code>unlink</code> 检查，在堆的后向合并过程中构造出 <code>chunk overlapping</code>。</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C、chunk D</code>，<code>chunk D</code> 用来做 <code>gap</code>，<code>chunk A、chunk C</code> 都要处于 <code>unsortedbin</code> 范围</li>
<li>释放 <code>A</code>，进入 <code>unsortedbin</code></li>
<li>对 <code>B</code> 写操作的时候存在 <code>off by null</code>，修改了 <code>C</code> 的 <code>P</code> 位</li>
<li>释放 <code>C</code> 的时候，堆后向合并，直接把 <code>A、B、C</code> 三块内存合并为了一个 <code>chunk</code>，并放到了 <code>unsortedbin</code> 里面</li>
<li>读写合并后的大 <code>chunk</code> 可以操作 <code>chunk B</code> 的内容，<code>chunk B</code> 的头</li>
</ul>
<h3 id="相关技巧-1">相关技巧
</h3><p>虽然该利用技巧至今仍可以利用，但是需要对 <code>unlink</code> 绕过的条件随着版本的增加有所变化。</p>
<p>最开始的 <code>unlink</code> 的代码是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* Take a chunk off a bin list */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define unlink(AV, P, BK, FD) {                                            
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">FD</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>								      
</span></span><span class="line"><span class="cl">    <span class="n">BK</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>								      
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">__builtin_expect</span> <span class="p">(</span><span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">P</span> <span class="o">||</span> <span class="n">BK</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>		      
</span></span><span class="line"><span class="cl">      <span class="nf">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="s">&#34;corrupted double-linked list&#34;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">AV</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>								      
</span></span><span class="line"><span class="cl">		<span class="c1">// .....							      
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>									      
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>只需要绕过<code>__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)</code> 即可，因此，不需要伪造地址处于高位的 <code>chunk</code> 的 <code>presize</code> 域。</p>
<p>高版本的 <code>unlink</code> 的条件是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* Take a chunk off a bin list.  */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">unlink_chunk</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">prev_size</span> <span class="p">(</span><span class="nf">next_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">malloc_printerr</span> <span class="p">(</span><span class="s">&#34;corrupted size vs. prev_size&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mchunkptr</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mchunkptr</span> <span class="n">bk</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__builtin_expect</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">malloc_printerr</span> <span class="p">(</span><span class="s">&#34;corrupted double-linked list&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>新增了 <code>chunksize (p) != prev_size (next_chunk (p))</code>，对 <code>chunksize</code> 有了检查，伪造的时候需要绕过。</p>
<h3 id="利用效果-1">利用效果
</h3><ul>
<li>构造 <code>chunk overlap</code> 后，可以任意地址分配</li>
<li>结合其他方法进行任意地址读写</li>
</ul>
<h2 id="23-house-of-force">2.3-House of Force
</h2><blockquote>
<p>[!NOTE]</p>
<p>主要思路为：将<code>top chunk</code>的<code>size</code>改为一个很大的数，就可以始终让<code>top chunk</code>满足切割条件，而恰好又没有对其的检查，故可利用此漏洞，<code>top chunk</code>的地址加上所请求的空间大小造成了整型溢出，使得<code>top chunk</code>被转移到内存中的低地址区域（如<code>bss</code>段，<code>data</code>段，<code>got</code>表等等），接下来再次请求空间，就可以获得转移地址后面的内存区域的控制权。</p>
<ol>
<li>直接将<code>top chunk</code>的<code>size</code>域赋成<code>-1</code>，通过整型溢出为<code>0xffffffffffffffff</code>。</li>
<li>将需要申请的<code>evil_size</code>设为<code>target_addr - top_ptr - 0x10*2</code>，这里的<code>top_ptr</code>指向<code>top chunk</code>的<code>chunk header</code>处。</li>
<li>通过<code>malloc(evil_size)</code>申请堆块，此时由于<code>top chunk</code>的<code>size</code>很大，会绕过检查，通过<code>top chunk</code>进行分配，分配后，<code>top chunk</code>被转移到：<code>top_ptr + (evil_size + 0x10) = target_addr - 0x10</code>处。</li>
<li>之后，再申请<code>P = malloc(X)</code>，则此时<code>P</code>指向<code>target_addr</code>，继而可对此地址进行任意读写的操作。</li>
</ol>
</blockquote>
<h3 id="漏洞成因-2">漏洞成因
</h3><p>堆溢出写 <code>top_chunk</code></p>
<h3 id="适用范围-2">适用范围
</h3><ul>
<li><code>2.23</code>——<code>2.29</code></li>
<li>可分配任意大小的 <code>chunk</code></li>
<li>需要泄露或已知地址</li>
</ul>
<h3 id="利用原理-2">利用原理
</h3><p>对 <code>top_chunk</code> 的利用，过程如下：</p>
<ul>
<li>申请 <code>chunk A</code></li>
<li>写 <code>A</code> 的时候溢出，修改 <code>top_chunk</code> 的 <code>size</code> 为很大的数</li>
<li>分配很大的 <code>chunk</code> 到任意已知地址</li>
</ul>
<h3 id="相关技巧-2">相关技巧
</h3><p>注意，在 <code>glibc-2.29</code> 后加入了检测，<code>house of force</code> 基本失效：</p>
<img src="C:\Users\Alesst\AppData\Roaming\Typora\typora-user-images\image-20260131091135312.png" alt="image-20260131091135312" style="zoom: 67%;" />
<h3 id="利用效果-2">利用效果
</h3><ul>
<li>任意地址分配</li>
<li>任意地址读写</li>
</ul>
<h2 id="24-house-of-lore">2.4-House of Lore
</h2><h3 id="漏洞成因-3">漏洞成因
</h3><p>堆溢出、<code>use after free</code>、<code>edit after free</code></p>
<h3 id="适用范围-3">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>需要泄露或已知地址</li>
</ul>
<h3 id="利用原理-3">利用原理
</h3><p>控制 <code>smallbin</code> 的 <code>bk</code> 指针，示例如下：</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C</code>，其中 <code>chunk B</code> 大小位于 <code>smallbin</code></li>
<li>释放 <code>B</code>，申请更大的 <code>chunk D</code>，使得 <code>B</code> 进入 <code>smallbin</code></li>
<li>写 <code>A</code>，溢出修改 <code>B</code> 的 <code>bk</code>，指向地址 <code>X</code>，这里有 <code>fake chunk</code></li>
<li>布置 <code>X-&gt;fd == &amp;B</code></li>
<li>分配两次后即可取出位于 <code>X</code> 地址处的 <code>fake chunk</code></li>
</ul>
<h3 id="相关技巧-3">相关技巧
</h3><p>在引入了 <code>tcache stash unlink</code> 的时候，需要注意绕过：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#if USE_TCACHE
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	  <span class="cm">/* While we&#39;re here, if we see other chunks of the same size,
</span></span></span><span class="line"><span class="cl"><span class="cm">	     stash them in the tcache.  */</span>
</span></span><span class="line"><span class="cl">	  <span class="kt">size_t</span> <span class="n">tc_idx</span> <span class="o">=</span> <span class="nf">csize2tidx</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="k">if</span> <span class="p">(</span><span class="n">tcache</span> <span class="o">&amp;&amp;</span> <span class="n">tc_idx</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">tcache_bins</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	    <span class="p">{</span>
</span></span><span class="line"><span class="cl">	      <span class="n">mchunkptr</span> <span class="n">tc_victim</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	      <span class="cm">/* While bin not empty and tcache not full, copy chunks over.  */</span>
</span></span><span class="line"><span class="cl">	      <span class="k">while</span> <span class="p">(</span><span class="n">tcache</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">tcache_count</span>
</span></span><span class="line"><span class="cl">		     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tc_victim</span> <span class="o">=</span> <span class="nf">last</span> <span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">		  <span class="k">if</span> <span class="p">(</span><span class="n">tc_victim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		    <span class="p">{</span>
</span></span><span class="line"><span class="cl">		      <span class="n">bck</span> <span class="o">=</span> <span class="n">tc_victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		      <span class="nf">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">tc_victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		      <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">set_non_main_arena</span> <span class="p">(</span><span class="n">tc_victim</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		      <span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		      <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		      <span class="nf">tcache_put</span> <span class="p">(</span><span class="n">tc_victim</span><span class="p">,</span> <span class="n">tc_idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	            <span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>要么使其满足 <code>tc_victim = last (bin)) == bin</code>、要么使其满足：<code>tcache-&gt;counts[tc_idx] ≥ mp_.tcache_count</code>。否则可能会因为非法内存访问使得程序 <code>down</code> 掉。</p>
<p>实际上，这个技巧用得不是很多，因为在同等条件下，更偏向于利用 <code>fastbin/tcachebin</code>。</p>
<h3 id="利用效果-3">利用效果
</h3><ul>
<li>任意地址分配</li>
<li>任意地址读写</li>
</ul>
<h2 id="25-house-of-orange">2.5-House of Orange
</h2><h3 id="漏洞成因-4">漏洞成因
</h3><p>堆溢出写</p>
<h3 id="适用范围-4">适用范围
</h3><ul>
<li><code>2.23</code>——<code>2.26</code></li>
<li>没有 <code>free</code></li>
<li>可以 <code>unsortedbin attack</code></li>
</ul>
<h3 id="利用原理-4">利用原理
</h3><p><code>house of orange</code> 可以说是开启了堆与 <code>IO</code> 组合利用的先河，是非常经典、漂亮、精彩的利用组合技。利用过程还要结合 <code>top_chunk</code> 的性质，利用过程如下：</p>
<p><strong>stage1</strong></p>
<ul>
<li>申请 <code>chunk A</code>，假设此时的 <code>top_chunk</code> 的 <code>size</code> 为 <code>0xWXYZ</code></li>
<li>写 <code>A</code>，溢出修改 <code>top_chunk</code> 的 <code>size</code> 为 <code>0xXYZ</code>（需要满足页对齐的检测条件）</li>
<li>申请一个大于 <code>0xXYZ</code> 大小的 <code>chunk</code>，此时 <code>top_chunk</code> 会进行 <code>grow</code>，并将原来的 <code>old top_chunk</code> 释放进入 <code>unsortedbin</code></li>
</ul>
<p><strong>stage2</strong></p>
<ul>
<li>溢出写 <code>A</code>，修改处于 <code>unsortedbin</code> 中的 <code>old top_chunk</code>，修改其 <code>size</code> 为 <code>0x61</code>，其 <code>bk</code> 为 <code>&amp;_IO_list_all-0x10</code>，同时伪造好 <code>IO_FILE</code> 结构</li>
<li>申请非 <code>0x60</code> 大小的 <code>chunk</code> 的时候，首先触发 <code>unsortedbin attack</code>，将<code>_IO_list_all</code> 修改为 <code>main_arena+88</code>，然后 <code>unsortedbin chunk</code> 会进入到 <code>smallbin</code>，大小为 <code>0x60</code>；接着遍历 <code>unsortedbin</code> 的时候触发了 <code>malloc_printerr</code>，然后调用链为：<code> malloc_printerr -&gt; libc_message -&gt; abort -&gt; _IO_flush_all_lockp</code>，调用到伪造的 <code>vtable</code> 里面的函数指针</li>
</ul>
<h3 id="相关技巧-4">相关技巧
</h3><ul>
<li>在 <code>glibc-2.24</code> 后加入了 <code>vtable</code> 的 <code>check</code>，不能任意地址伪造 <code>vatble</code> 了，但是可以利用 <code>IO_str_jumps</code> 结构进行利用。</li>
<li>在 <code>glibc-2.26</code> 后，<code>malloc_printerr</code> 不再刷新 <code>IO</code> 流了，所以该方法失效</li>
<li>由于<code>_mode</code> 的正负性是随机的，影响判断条件，大概有 <code>1/2</code> 的概率会利用失败，多试几次就好</li>
</ul>
<h3 id="利用效果-4">利用效果
</h3><ul>
<li>任意函数执行</li>
<li>任意命令执行</li>
</ul>
<h2 id="26-house-of-rabbit">2.6-House of Rabbit
</h2><blockquote>
<p>[!NOTE]</p>
<h4 id="house-of-rabbit是利用malloc_consolidate合并机制的一种方法"><code>house of rabbit</code>是利用<code>malloc_consolidate()</code>合并机制的一种方法。
</h4><p><code>malloc_consolidate()</code>函数会将<code>fastbin</code>中的堆块之间或其中堆块与相邻的<code>freed</code>状态的堆块合并在一起，最后达到的效果就是将合并完成的堆块（或<code>fastbin</code>中的单个堆块）放进了<code>smallbin/largebin</code>中，在此过程中，并不会对<code>fastbin</code>中堆块的<code>size</code>或<code>fd</code>指针进行检查，这是一个可利用点。</p>
<ol>
<li><code>fastbin</code>中的堆块<code>size</code>可控（比如<code>off by one</code>等）
比如现在<code>fastbin</code>有两个<code>0x20</code>的堆块<code>A -&gt; B</code>，其中<code>chunk B</code>在<code>chunk A</code>的上方，我们将<code>chunk B</code>的<code>size</code>改为<code>0x40</code>，这样就正好包含了<code>chunk A</code>，且<code>fake chunk B</code>下面的堆块也就是<code>chunk A</code>下方的堆块，也是合法的，假设这个堆块不是<code>freed</code>的状态，那么触发<code>malloc_consolidate()</code>之后，<code>smallbin</code>里就会有两个堆块，一个是<code>chunk A</code>，另外一个是<code>fake chunk B</code>，其中包含了<code>chunk A</code>，这样就实现了堆块重叠。</li>
<li><code>fastbin</code>中的堆块<code>fd</code>可控（比如<code>UAF</code>漏洞等）
其实就是将<code>fastbin</code>中的堆块的<code>fd</code>改为指向一个<code>fake chunk</code>，然后通过触发<code>malloc_consolidate()</code>之后，使这个<code>fake chunk</code>完全“合法化”。不过，需要注意伪造的是<code>fake chunk's next chunk</code>的<code>size</code>与其<code>next chunk's next chunk</code>的<code>size</code>（<code>prev_inuse</code>位要为<code>1</code>）。</li>
</ol>
</blockquote>
<h3 id="漏洞成因-5">漏洞成因
</h3><p>堆溢出写、<code>use after free</code>、<code>edit after free</code></p>
<h3 id="适用范围-5">适用范围
</h3><ul>
<li><code>2.23</code>——<code>2.26</code></li>
<li>超过 <code>0x400</code> 大小的堆分配</li>
<li>可以写 <code>fastbin</code> 的 <code>fd</code> 或者 <code>size</code> 域</li>
</ul>
<h3 id="利用原理-5">利用原理
</h3><p>该利用技巧的核心是 <code>malloc_consolidate</code> 函数，当检测到有 <code>fastbin</code> 的时候，会取出每一个 <code>fastbin chunk</code>，将其放置到 <code>unsortedbin</code> 中，并进行合并。以修改 <code>fd</code> 为例，利用过程如下：</p>
<ul>
<li>申请 <code>chunk A</code>、<code>chunk B</code>，其中 <code>chunk A</code> 的大小位于 <code>fastbin</code> 范围</li>
<li>释放 <code>chunk A</code>，使其进入到 <code>fastbin</code></li>
<li>利用 <code>use after free</code>，修改 <code>A-&gt;fd</code> 指向地址 <code>X</code>，需要伪造好 <code>fake chunk</code>，使其不执行 <code>unlink</code> 或者绕过 <code>unlink</code></li>
<li>分配足够大的 <code>chunk</code>，或者释放 <code>0x10000</code> 以上的 <code>chunk</code>，只要能触发 <code>malloc_consolidate</code> 即可</li>
<li>此时 <code>fake chunk</code> 被放到了 <code>unsortedbin</code>，或者进入到对应的 <code>smallbin/largebin</code></li>
<li>取出 <code>fake chunk</code> 进行读写即可</li>
</ul>
<h3 id="相关技巧-5">相关技巧
</h3><ul>
<li><code>2.26</code> 加入了 <code>unlink</code> 对 <code>presize</code> 的检查</li>
<li><code>2.27</code> 加入了 <code>fastbin</code> 的检查</li>
</ul>
<p>抓住重点：<code>house of rabbit</code> 是对 <code>malloc_consolidate</code> 的利用。因此，不一定要按照原作者的思路来，他的思路需要满足的条件太多了。</p>
<h3 id="利用效果-5">利用效果
</h3><ul>
<li>任意地址分配</li>
<li>任意地址读写</li>
</ul>
<h2 id="27-house-of-roman">2.7-House of Roman
</h2><h3 id="漏洞成因-6">漏洞成因
</h3><p><code>use after free</code>、堆溢出</p>
<h3 id="适用范围-6">适用范围
</h3><ul>
<li><code>2.23</code>——<code>2.29</code></li>
<li>可以 <code>use after edit</code></li>
<li>不需要泄露地址</li>
<li>需要爆破 <code>12 bit</code>，成功的概率 <code>1/4096</code></li>
</ul>
<h3 id="利用原理-6">利用原理
</h3><p>可以说这个技巧是 <code>fastbin attack + unsortedbin attack</code> 的组合技，利用思路如下：</p>
<ul>
<li>申请 <code>chunk A</code>、<code>chunk B</code>、<code>chunk C</code> 和 <code>chunk D</code>，<code>chunk B</code> 的大小为 <code>0x70</code></li>
<li>释放 <code>chunk B</code>，使其进入到 <code>fastbin[0x70]</code></li>
<li>溢出写 <code>A</code>，修改 <code>chunk B</code> 的 <code>size</code>，使其大小在 <code>unsortedbin</code> 范围</li>
<li>再次释放 <code>B</code>，<code>B</code> 进入 <code>unsortedbin</code> 中</li>
<li>部分写 <code>B</code> 的 <code>fd</code>，使得 <code>fd</code> 指向 <code>malloc_hook-0x23</code></li>
<li>利用 <code>A</code> 的溢出写修正 <code>B</code> 的 <code>size</code>，连续分配两次 <code>0x70</code>，即可分配到 <code>malloc_hook</code> 上方</li>
<li>触发 <code>unsortedbin attack</code>，将<code>__malloc_hook</code> 写为 <code>main_arena+88</code></li>
<li>部分写<code>__malloc_hook</code> 的低三个字节，修改为 <code>one_gadget</code></li>
<li>再次 <code>malloc</code> 即可拿到 <code>shell</code></li>
</ul>
<h3 id="相关技巧-6">相关技巧
</h3><ul>
<li>使用 <code>house of roman</code> 的时候，需要采用多线程爆破</li>
<li>可以使用其他方法代替，比如先攻击 <code>stdout</code> 泄露地址，使得爆破的成本降低</li>
</ul>
<h3 id="利用效果-6">利用效果
</h3><ul>
<li>执行 <code>one_gadget</code></li>
<li>绕过 <code>ASLR</code></li>
</ul>
<h2 id="28-house-of-storm">2.8-House of Storm
</h2><h3 id="漏洞成因-7">漏洞成因
</h3><p>堆溢出、<code>use after free</code>、<code>edit after free</code></p>
<h3 id="适用范围-7">适用范围
</h3><ul>
<li><code>2.23</code>——<code>2.29</code></li>
<li>可以进行 <code>unsortedbin attack</code></li>
<li>可以进行 <code>largebin attack</code>，修改 <code>bk</code> 和 <code>bk_nextsize</code></li>
<li>可以分配 <code>0x50</code> 大小的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-7">利用原理
</h3><p><code>house of storm</code> 也是一款组合技，利用开启了 <code>PIE</code> 的 <code>x64</code> 程序的堆地址总是 <code>0x55xxxx...</code> 或者 <code>0x56xxxx...</code> 开头这一特性，使用一次 <code>largebin attack</code> 写两个堆地址，使用一次 <code>unsortedbin attack</code> 写一次 <code>libc</code> 地址，可以实现任意地址分配。虽然 <code>house of storm</code> 最后能达到任意地址分配，但是由于其所需的条件比较多，一般可以用其他更简便的堆利用技术代替。利用思路如下：</p>
<ul>
<li>进行一次 <code>unsortedbin attack</code>，其 <code>bk</code> 修改为 <code>addr</code></li>
<li>进行一次 <code>largebin attack</code>，其 <code>bk</code> 修改为 <code>addr+0x10</code>，<code>bk_nextsize</code> 修改为 <code>addr-0x20+3</code></li>
<li>申请 <code>0x50</code> 大小的 <code>chunk</code> 即可申请到 <code>addr</code> 处</li>
</ul>
<h3 id="相关技巧-7">相关技巧
</h3><p>需要注意的有：</p>
<ul>
<li>该方法成功的几率是 <code>50%</code>，因为 <code>0x55</code> 会触发 <code>assert</code> 断言，<code>0x56</code> 才能成功</li>
<li>申请 <code>addr</code> 处的 <code>chunk</code> 的时候需要从 <code>unsortedbin</code> 里面取</li>
</ul>
<h3 id="利用效果-7">利用效果
</h3><ul>
<li>任意地址分配</li>
</ul>
<h2 id="29-house-of-corrosion">2.9-House of Corrosion
</h2><h3 id="漏洞成因-8">漏洞成因
</h3><p>堆溢出、<code>use after free</code></p>
<h3 id="适用范围-8">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>任意大小分配</li>
<li>可以修改 <code>global_max_fast</code></li>
<li>不需要泄露地址</li>
</ul>
<h3 id="利用原理-8">利用原理
</h3><p>一个非常 <code>tricky</code> 的方法，可以绕过 <code>aslr</code>，不需要泄露地址都能达成 <code>rce</code>，可以很很多方法结合起来应用。先说利用原理：</p>
<ul>
<li>使用 <code>unsortedbin attack/largebin attack</code> 等方法，成功修改 <code>global_max_fast</code> 的值为很大的值。如果使用 <code>unsortedbin attack</code>，不需要泄露地址，爆破 <code>1/16</code> 即可</li>
<li>申请任意大小的 <code>chunk</code>，这些 <code>chunk</code> 都会被视为 <code>fastbin chunk</code>，然后利用这些 <code>chunk</code> 来进行读和写</li>
</ul>
<p>此时的计算公式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">chunk size = (chunk addr - &amp;main_arena.fastbinsY) x 2 + 0x20
</span></span></code></pre></td></tr></table>
</div>
</div><p>读原语：</p>
<ul>
<li>假设对应的地址 <code>X</code> 上存储着 <code>Y</code>，现在的目的是泄露出 <code>Y</code></li>
<li>根据偏移计算出来 <code>chunk size</code>，修改 <code>chunk A</code> 的 <code>size</code> 为计算出来的值，释放 <code>chunk A</code> 到地址 <code>X</code> 处</li>
<li>此时，<code>A-&gt;fd</code> 就被写入了 <code>Y</code></li>
<li>通过打印即可泄露出 <code>Y</code> 的信息</li>
</ul>
<p>写原语 <code>1</code>：</p>
<ul>
<li>假设对应的地址 <code>X</code> 上存储着 <code>Y</code>，现在的目的是修改地址 <code>X</code> 存储的 <code>Y</code> 为其他值</li>
<li>根据偏移计算出来 <code>chunk size</code>，修改 <code>chunk A</code> 的 <code>size</code> 为计算出来的值，释放 <code>chunk A</code> 到地址 <code>X</code> 处</li>
<li>此时，<code>A-&gt;fd</code> 就被写入了 <code>Y</code></li>
<li>修改 <code>A-&gt;fd</code> 为目标值</li>
<li>分配一次 <code>chunk A</code> 就可以把地址 <code>X</code> 存储的值为任意值</li>
</ul>
<p>写原语 <code>2</code>：</p>
<ul>
<li>假设地址 <code>X</code> 上存储着 <code>Y</code>、地址 <code>M</code> 上存储着 <code>N</code>，现在的目的是把 <code>N</code> 写到地址 <code>X</code> 处</li>
<li>根据偏移计算 <code>chunk size1</code>，先释放 <code>chunk A</code> 到地址 <code>X</code> 处，此时有地址 <code>X</code> 处存储 <code>chunk A</code> 地址，<code>chunk A-&gt;fd</code> 为 <code>Y</code></li>
<li>根据偏移计算 <code>chunk size2</code>，再次释放 <code>chunk A</code> 到地址 <code>M</code> 处，此时有地址 <code>M</code> 处存储 <code>chunk A</code> 地址，<code>chunk A-&gt;fd</code> 为 <code>N</code></li>
<li>修正 <code>chunk A</code> 的大小为 <code>chunk size1</code>，分配 <code>1</code> 次 <code>chunk</code> 即可使得 <code>N</code> 转移到地址 <code>X</code> 处，当然在转移的过程中可以适当的修改 <code>N</code></li>
</ul>
<p>显然，借助写原语 <code>2</code>，即可在不需要泄露地址的前提下将<code>__malloc_hook</code> 等写为 <code>one_gadget</code>，爆破的概率是 <code>1/4096</code>。</p>
<h3 id="相关技巧-8">相关技巧
</h3><ul>
<li>虽然至今都能使用 <code>house of corrosion</code>，但是在 <code>glibc-2.37</code> 版本中，<code>global_max_fast</code> 的数据类型被修改为了 <code>int8_u</code>，进而导致可控的空间范围大幅度缩小。</li>
<li><code>house of corrosion</code> 也可以拓展到 <code>tcachebin</code> 上</li>
<li>适当控制 <code>global_max_fast</code> 的大小，把握控制的空间范围</li>
<li>可以和 <code>IO_FILE</code> 结合起来泄露信息</li>
</ul>
<h3 id="利用效果-8">利用效果
</h3><ul>
<li><code>glibc</code> 上的地址泄露</li>
<li>执行 <code>one_gadget</code></li>
</ul>
<h2 id="210-house-of-husk">2.10-House of Husk
</h2><h3 id="漏洞成因-9">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-9">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以修改<code>__printf_arginfo_table</code> 和<code>__printf_function_table</code></li>
<li>可触发格式化字符串解析</li>
</ul>
<h3 id="利用原理-9">利用原理
</h3><p>严格来说，这个漏洞是与堆的关系并不是很大，主要是根据 <code>printf</code> 的机制进行利用。但是，该技术可以和很多堆利用手法结合起来。</p>
<p>调用处 <code>1</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* Use the slow path in case any printf handler is registered.  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">__glibc_unlikely</span> <span class="p">(</span><span class="n">__printf_function_table</span> <span class="o">!=</span> <span class="nb">NULL</span>
</span></span><span class="line"><span class="cl">			<span class="o">||</span> <span class="n">__printf_modifier_table</span> <span class="o">!=</span> <span class="nb">NULL</span>
</span></span><span class="line"><span class="cl">			<span class="o">||</span> <span class="n">__printf_va_arg_table</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">do_positional</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// vfprintf-internal.c#1763
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">nargs</span> <span class="o">+=</span> <span class="nf">__parse_one_specmb</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">specs</span><span class="p">[</span><span class="n">nspecs</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">max_ref_arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// printf-parsemb.c (__parse_one_specmb函数)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/* Get the format specification.  */</span>
</span></span><span class="line"><span class="cl"><span class="n">spec</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">spec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">wchar_t</span><span class="p">)</span> <span class="o">*</span><span class="n">format</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">spec</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">__builtin_expect</span> <span class="p">(</span><span class="n">__printf_function_table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 判断是否为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">||</span> <span class="n">spec</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">spec</span> <span class="o">&gt;</span> <span class="n">UCHAR_MAX</span>
</span></span><span class="line"><span class="cl">  <span class="o">||</span> <span class="n">__printf_arginfo_table</span><span class="p">[</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">spec</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="c1">// 判断是否为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* We don&#39;t try to get the types for all arguments if the format
</span></span></span><span class="line"><span class="cl"><span class="cm"> uses more than one.  The normal case is covered though.  If
</span></span></span><span class="line"><span class="cl"><span class="cm"> the call returns -1 we continue with the normal specifiers.  */</span>
</span></span><span class="line"><span class="cl">  <span class="o">||</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">ndata_args</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">__printf_arginfo_table</span><span class="p">[</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">spec</span><span class="p">])</span> <span class="c1">// 调用__printf_arginfo_table中的函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="p">(</span><span class="o">&amp;</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">data_arg_type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">&amp;</span><span class="n">spec</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>利用方式为：</p>
<ul>
<li><code>__printf_function_table</code> 和<code>__printf_arginfo_table</code> 分别写为 <code>chunk A</code> 和 <code>chunk B</code> 的地址</li>
<li>设占位符为 <code>α</code>，此时 <code>chunk B</code> 的内容应该为 <code>p64(0) x ord(α-2) + p64(one_gadget)</code></li>
</ul>
<p>调用处 <code>2</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// vfprintf-internal.c#1962
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">spec</span> <span class="o">&lt;=</span> <span class="n">UCHAR_MAX</span>
</span></span><span class="line"><span class="cl">          <span class="o">&amp;&amp;</span> <span class="n">__printf_function_table</span> <span class="o">!=</span> <span class="nb">NULL</span>
</span></span><span class="line"><span class="cl">          <span class="o">&amp;&amp;</span> <span class="n">__printf_function_table</span><span class="p">[(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">spec</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">      <span class="cm">/* Call the function.  */</span>
</span></span><span class="line"><span class="cl">      <span class="n">function_done</span> <span class="o">=</span> <span class="n">__printf_function_table</span><span class="p">[(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">spec</span><span class="p">](</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">specs</span><span class="p">[</span><span class="n">nspecs_done</span><span class="p">].</span><span class="n">info</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="c1">// 调用__printf_function_table中的函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">function_done</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* If an error occurred we don&#39;t have information
</span></span></span><span class="line"><span class="cl"><span class="cm">         about # of chars.  */</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">function_done</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="cm">/* Function has set errno.  */</span>
</span></span><span class="line"><span class="cl">          <span class="n">done</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">goto</span> <span class="n">all_done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">      <span class="nf">done_add</span> <span class="p">(</span><span class="n">function_done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>利用方式为：</p>
<ul>
<li><code>__printf_function_table</code> 和<code>__printf_arginfo_table</code> 分别写为 <code>chunk A</code> 和 <code>chunk B</code> 的地址</li>
<li>设占位符为 <code>α</code>，此时 <code>chunk A</code> 的内容应该为 <code>p64(0) x ord(α-2) + p64(one_gadget)</code></li>
</ul>
<p>该处调用在高版本被删除。</p>
<h3 id="相关技巧-9">相关技巧
</h3><ul>
<li>该技巧一般和 <code>largebin attack</code> 结合起来</li>
<li>在低于 <code>2.36</code> 版本中，<code>__malloc_assert</code> 中有格式化字符串的解析</li>
<li>还有一个<code>__printf_va_arg_table</code> 也是可以利用的，但是条件比较苛刻</li>
</ul>
<h3 id="利用效果-9">利用效果
</h3><ul>
<li>执行 <code>one_gadget</code></li>
<li>执行 <code>rop</code> 控制程序执行流</li>
</ul>
<h2 id="211-house-of-atum">2.11-House of Atum
</h2><h3 id="漏洞成因-10">漏洞成因
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">edit after free
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="适用范围-10">适用范围
</h3><ul>
<li><code>2.26</code>——<code>2.30</code></li>
<li>可以修改 <code>tcachebin</code> 的 <code>next</code> 和 <code>key</code></li>
</ul>
<h3 id="利用原理-10">利用原理
</h3><p>这是一个关于 <code>tcachebin</code> 的技巧，用于修改 <code>chunk presize/size</code>，利用过程如下：</p>
<ul>
<li>申请 <code>chunk A</code>，大小在 <code>fastbin</code> 范围内</li>
<li>释放 <code>A</code>，连续释放 <code>8</code> 次，此时，<code>A</code> 的 <code>fd</code> 被清 <code>0</code>，<code>A</code> 也被放置到了 <code>fastbin</code> 里面</li>
<li>申请一个 <code>chunk</code>，将其 <code>fd</code> 修改为 <code>A - 0x10</code>，此时 <code>tcache</code> 中的 <code>counts</code> 为 <code>6</code></li>
<li>再申请一个 <code>chunk</code>，从 <code>fastbin</code> 里面取，但是会把 <code>fastbin</code> 里面剩余的一个 <code>chunk</code> 链入到 <code>tcachebin</code></li>
<li>再次分配就会分配到地址 <code>A-0x10</code> 处，就可以修改原来 <code>A</code> 的 <code>presize/size</code> 等</li>
</ul>
<h3 id="相关技巧-10">相关技巧
</h3><ul>
<li><code>2.30</code> 之后逻辑变了，原来是判断 <code>entry[idx]!=NULL</code>，<code>2.31</code> 之后判断 <code>count[idx] &gt; 0</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// glibc ≥ 2.30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">__libc_malloc</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">MAYBE_INIT_TCACHE</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">DIAG_PUSH_NEEDS_COMMENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">tc_idx</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">tcache_bins</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;&amp;</span> <span class="n">tcache</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;&amp;</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">tcache_get</span> <span class="p">(</span><span class="n">tc_idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// glibc &lt; 2.30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nf">__libc_malloc</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">MAYBE_INIT_TCACHE</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">DIAG_PUSH_NEEDS_COMMENT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">tc_idx</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">tcache_bins</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;&amp;</span> <span class="n">tcache</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;&amp;</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nf">tcache_get</span> <span class="p">(</span><span class="n">tc_idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>有时候需要绕过 <code>tcache-&gt;key</code> 的检测</li>
</ul>
<h3 id="利用效果-10">利用效果
</h3><ul>
<li>修改 <code>chunk size</code> 以及 <code>chunk presize</code></li>
</ul>
<h2 id="212-house-of-kauri">2.12-House of Kauri
</h2><h3 id="漏洞成因-11">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-11">适用范围
</h3><ul>
<li><code>2.26</code>——<code>2.32</code></li>
</ul>
<h3 id="利用原理-11">利用原理
</h3><p>利用原理很简单，修改 <code>tcachebin</code> 的 <code>size</code>，然后使其被放到不同大小的 <code>tcachebin</code> 链表里面去。我感觉这个技巧是很基础的 <code>tcachebin</code> 技巧，甚至不应该被称之为 <code>house of</code>。</p>
<h3 id="相关技巧-11">相关技巧
</h3><ul>
<li>无</li>
</ul>
<h3 id="利用效果-11">利用效果
</h3><ul>
<li>多个 <code>tcachebin</code> 链表中存放同一个 <code>chunk</code></li>
</ul>
<h2 id="213-house-of-fun">2.13-House of Fun
</h2><h3 id="漏洞成因-12">漏洞成因
</h3><p>堆溢出、<code>use after free</code></p>
<h3 id="适用范围-12">适用范围
</h3><ul>
<li><code>2.23</code>——<code>2.30</code></li>
<li>可以申请 <code>largebin</code> 范围的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-12">利用原理
</h3><p>或许这个技巧应该叫做 <code>largebin attack</code>。</p>
<p>在这个 <a class="link" href="https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=801ba1f499b566e677b763fc84f8ba86f4f7ccd0;hp=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=5b06f538c5aee0389ed034f60d90a8884d6d54de;hpb=a0a0dc83173ce11ff45105fd32e5d14356cdfb9c"  target="_blank" rel="noopener"
    >sourceware.org Git - glibc.git/blobdiff - malloc/malloc.c</a><code>commit</code> 被检测了：</p>
<img src="C:\Users\Alesst\AppData\Roaming\Typora\typora-user-images\image-20260131091454186.png" alt="image-20260131091454186" style="zoom: 67%;" />
<h3 id="相关技巧-12">相关技巧
</h3><ul>
<li>无</li>
</ul>
<h3 id="利用效果-12">利用效果
</h3><ul>
<li>任意地址写堆地址</li>
</ul>
<h2 id="214-house-of-mind">2.14-House of Mind
</h2><h3 id="漏洞成因-13">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-13">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以分配任意大小的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-13">利用原理
</h3><p>主要利用的是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define heap_for_ptr(ptr) \
</span></span></span><span class="line"><span class="cl"><span class="cp">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define arena_for_chunk(ptr) \
</span></span></span><span class="line"><span class="cl"><span class="cp">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果是 <code>non-mainarean</code> 的 <code>chunk</code>，会根据其地址找到 <code>heapinfo</code>，然后找到 <code>malloc_state</code> 结构体。</p>
<p>因此，利用技巧是：</p>
<ul>
<li>根据要释放的 <code>fastbin chunk A</code> 的堆地址，找到对应的 <code>heap_for_ptr</code> 地址</li>
<li>在 <code>heapinfo</code> 地址处伪造好相关变量，重点是 <code>mstate</code> 指针</li>
<li>修改 <code>chunk A</code> 的 <code>non-main</code> 标志位，释放到伪造的 <code>arena</code> 里面，控制好偏移即可</li>
</ul>
<h3 id="相关技巧-13">相关技巧
</h3><ul>
<li>一般来说，可以分配任意大小的 <code>chunk</code>，还能堆溢出，很多技巧都能用</li>
<li>这个技巧是希望大家关注对于 <code>arena</code> 的攻击</li>
<li>甚至可以直接修改 <code>thread_arena</code> 这个变量</li>
</ul>
<h3 id="利用效果-13">利用效果
</h3><ul>
<li>任意地址写堆地址</li>
</ul>
<h2 id="215-house-of-muney">2.15-House of Muney
</h2><h3 id="漏洞成因-14">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-14">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>能分配 <code>mmap</code> 的 <code>chunk</code></li>
<li>能修改 <code>mmap</code> 的 <code>chunk</code> 的大小</li>
</ul>
<h3 id="利用原理-14">利用原理
</h3><p>这个技巧被称之为 <code>steal heap from glibc</code>。主要的点有以下几个：</p>
<ul>
<li><code>libc.so.6</code> 映射的地址空间，前面都是与符号表、哈希表、字符串表等重定位或者解析函数地址有关，前面一段的权限是 <code>r--</code></li>
<li><code>mmap(NULL, ...)</code> 是会分配到 <code>libc.so.6</code> 的上方的</li>
</ul>
<p>基于这两个知识点，利用过程如下：</p>
<ul>
<li>申请 <code>chunk A</code>，假设为 <code>0x40000</code> 大小，则会走 <code>mmap</code> 申请，并且申请到 <code>libc.so.6</code> 的上方</li>
<li>修改 <code>chunk A</code> 的大小为 <code>0x45000</code>，设置 <code>MMAP</code> 标志位</li>
<li>释放 <code>chunk A</code>，则会把 <code>libc.so.6</code> 的 <code>0x5000</code> 的内存也释放掉</li>
<li>再次申请 <code>0x45000</code>，就可以控制 <code>libc.so.6</code> 原来的符号表、哈希表等等</li>
<li>触发一次 <code>dl_runtime_resolve</code> 等就能控制程序执行任意代码</li>
</ul>
<h3 id="相关技巧-14">相关技巧
</h3><ul>
<li>需要伪造的符号表、哈希表等需要逐步调试</li>
<li>可以扩展为 <code>steal heap from everywhere</code></li>
</ul>
<h3 id="利用效果-14">利用效果
</h3><ul>
<li>任意代码执行</li>
</ul>
<h2 id="216-house-of-botcake">2.16-House of Botcake
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 在 2.29/2.27 高版本之后，glibc 为了防止攻击者简单的 Tcache Double Free，引入了对 Tcache Key 的检查</span>
</span></span><span class="line"><span class="cl"> <span class="n">size_t</span> <span class="n">tc_idx</span> <span class="o">=</span> <span class="n">csize2tidx</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tcache</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">tc_idx</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="o">.</span><span class="n">tcache_bins</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">/*</span> <span class="n">Check</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">it</span><span class="s1">&#39;s already in the tcache.  */</span>
</span></span><span class="line"><span class="cl">    <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">tcache_entry</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">/*</span> <span class="n">This</span> <span class="n">test</span> <span class="n">succeeds</span> <span class="n">on</span> <span class="n">double</span> <span class="n">free</span><span class="o">.</span>  <span class="n">However</span><span class="p">,</span> <span class="n">we</span> <span class="n">don</span><span class="s1">&#39;t 100%</span>
</span></span><span class="line"><span class="cl">       <span class="n">trust</span> <span class="n">it</span> <span class="p">(</span><span class="n">it</span> <span class="n">also</span> <span class="n">matches</span> <span class="n">random</span> <span class="n">payload</span> <span class="n">data</span> <span class="n">at</span> <span class="n">a</span> <span class="mi">1</span> <span class="ow">in</span>
</span></span><span class="line"><span class="cl">       <span class="mi">2</span><span class="o">^&lt;</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">chance</span><span class="p">),</span> <span class="n">so</span> <span class="n">verify</span> <span class="n">it</span><span class="s1">&#39;s not an unlikely</span>
</span></span><span class="line"><span class="cl">       <span class="n">coincidence</span> <span class="n">before</span> <span class="n">aborting</span><span class="o">.</span>  <span class="o">*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">tcache</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_tcache_double_free</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">tc_idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">         <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="nb">next</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s2">&#34;free(): double free detected in tcache 2&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">/*</span> <span class="n">If</span> <span class="n">we</span> <span class="n">get</span> <span class="n">here</span><span class="p">,</span> <span class="n">it</span> <span class="n">was</span> <span class="n">a</span> <span class="n">coincidence</span><span class="o">.</span>  <span class="n">We</span><span class="s1">&#39;ve wasted a</span>
</span></span><span class="line"><span class="cl">           <span class="n">few</span> <span class="n">cycles</span><span class="p">,</span> <span class="n">but</span> <span class="n">don</span><span class="s1">&#39;t abort.  */</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>1）破坏掉被free的堆块的Key，这样就不会进入第一层检查
2）改变被free的堆块的大小，这样虽然进入了第一层检查，但是在进行第二层遍历相同大小的Tcache链表的时候，由于glibc进入的是另一个大小的Tcache链表中去检查，所以也不会被第二层检查发现
3）house of botcake</p>
<h3 id="漏洞成因-15">漏洞成因
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">double free
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="适用范围-15">适用范围
</h3><ul>
<li><code>2.26</code>—— 至今</li>
<li>多次释放 <code>chunk</code> 的能力</li>
</ul>
<h3 id="利用原理-15">利用原理
</h3><p>该技巧可以用于绕过 <code>tcache-&gt;key</code> 的检查，利用过程如下：</p>
<ul>
<li>申请 <code>7</code> 个大小相同，大小大于 <code>0x80</code> 的 <code>chunk</code>，再申请三个，分别为 <code>chunk A</code> 和 <code>chunkB</code> 和 <code>chunk C</code></li>
<li>释放前 <code>7</code> 个chunk和 <code>chunk A</code>，(前面 <code>7</code> 个都会进入到 <code>tcachebin</code> 里面，<code>chunk A</code> 进入到 <code>unsortedbin</code>)</li>
<li>释放 <code>chunk B</code>，则 <code>chunk B</code> 会和 <code>chunk A</code> 合并</li>
<li>从 <code>tcachebin</code> 分配走一个</li>
<li>再次释放 <code>chunk B</code>，此时 <code>B</code> 同时存在与 <code>unsortedbin</code> 和 <code>tcachebin</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//分配七个填充堆块（小于最大的Tcache，大于最大的Fastbin），一个辅助堆块 prev ，一个利用堆块 victim
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">intptr_t</span> <span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">intptr_t</span><span class="o">*</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">intptr_t</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">intptr_t</span> <span class="o">*</span><span class="n">victim</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span> <span class="c1">// 防止合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//free 掉七个填充堆块，此时对应大小的 Tcache 被填满
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//free 掉利用堆块 victim，由于此时 Tcache 被填满，victim 进入 Unsortedbin（绕过了 key 的产生）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">free</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//free 掉辅助堆块 prev，此时俩 Unsortedbin 相邻，会触发 Unsortedbin Consolidate 合并成一个大堆块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">free</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//申请出一个堆块，此时会优先从 Tcache 中取出一个填充堆块腾出位置。然后再 Free 掉 victim ，victim 进入 Tcache，完成 Double Free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*VULNERABILITY*/</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span><span class="c1">// victim is already freed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/*VULNERABILITY*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>House of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。</p>
<p>此外 House of botcake 在条件合适的情况下，极其容易完成多次任意分配堆块，是相当好用的手法。</p>
<h3 id="相关技巧-15">相关技巧
</h3><ul>
<li>在高版本需要绕过指针保护的检查</li>
</ul>
<h3 id="利用效果-15">利用效果
</h3><ul>
<li>构造出堆重叠，为后续利用做准备</li>
</ul>
<h2 id="217-house-of-rust">2.17-House of Rust
</h2><h3 id="漏洞成因-16">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-16">适用范围
</h3><ul>
<li><code>2.26</code>—— 至今</li>
<li>可以进行 <code>tcache stash unlinking</code> 攻击</li>
<li>可以进行 <code>largebin attack</code></li>
<li>不需要泄露地址</li>
</ul>
<h3 id="利用原理-16">利用原理
</h3><p>原作者的博客写得很复杂，我这里提炼出关键信息。该技巧就是 <code>tcachebin stash unlinking</code>+<code>largebin attack</code> 的组合技巧。</p>
<p>首先需要知道 <code>tcachebin stash unlinking</code>，下面称之为 <code>TSU</code> 技巧：</p>
<ul>
<li><code>tcachebin[A]</code> 为空</li>
<li><code>smallbin[A]</code> 有 <code>8</code> 个</li>
<li>修改第 <code>8</code> 个 <code>smallbin chunk</code> 的 <code>bk</code> 为 <code>addr</code></li>
<li>分配 <code>malloc(A)</code> 的时候，<code>addr+0x10</code> 会被写一个 <code>libc</code> 地址</li>
</ul>
<p>还要知道 <code>tcachebin stash unlinking+</code>，下面称之为 <code>TSU+</code> 技巧：</p>
<ul>
<li><code>tcachebin[A]</code> 为空</li>
<li><code>smallbin[A]</code> 有 <code>8</code> 个</li>
<li>修改第 <code>7</code> 个 <code>smallbin chunk</code> 的 <code>bk</code> 为 <code>addr</code>，还要保证 <code>addr+0x18</code> 是一个合法可写的地址</li>
<li>分配 <code>malloc(A)</code> 的时候，<code>addr</code> 会被链入到 <code>tcachebin</code>，也就是可以分配到 <code>addr</code> 处</li>
</ul>
<p>以 <code>0x90</code> 大小的 <code>chunk</code> 为例，此时的 <code>tcache_key</code> 还是指向 <code>tcache_perthread_struct + 0x10</code> 的：</p>
<ul>
<li>第一步，把 <code>tcachebin[0x90]</code> 填满，把 <code>smallbin[0x90]</code> 也填满</li>
<li>第二步，把最后一个 <code>smallbin 0x90</code> 的 <code>chunk</code> 的 <code>size</code> 改成 <code>0xb0</code>，将其释放到 <code>tcachebin[0xb0]</code>，这一步主要是为了改变其 <code>bk</code> 指向 <code>tcache_perthread_struct + 0x10</code>，可以部分修改低位的字节，以便下一步分配到目标区域</li>
<li>第三步，使用 <code>largebin attack</code> 往上一步的 <code>bk-&gt;bk</code> 写一个合法地址，然后耗尽 <code>tcachebin[0x90]</code>，再分配的时候就会触发 <code>TSU+</code>，之后就能分配到 <code>tcache_perthread_struct </code>结构体</li>
<li>第四步，还是堆风水，但是用 <code>TSU</code> 技术，在 <code>tcache_perthread_struct</code> 上写一个 <code>libc</code> 地址（比前面一步要简单很多）</li>
<li>第五步，通过控制 <code>tcache_perthread_struct</code> 结构体，部分写上面的 <code>libc</code> 地址，分配到 <code>stdout</code> 结构体，泄露信息</li>
<li>第六步，通过控制 <code>tcache_perthread_struct</code> 结构体分配到任意地址</li>
</ul>
<p>上面的过程最好的情况下需要爆破 <code>1/16</code>，最差 <code>1/256</code>。</p>
<p>但是，<code>2.34</code> 之后，<code>tcache_key</code> 是一个随机数，不是 <code>tcache_perthread_struct + 0x10</code> 了。</p>
<p>所以，此时可以加上 <code>largebin attack</code>，把以上的第二步变为：继续用 <code>largebin attack</code> 向其 <code>bk</code> 写一个堆地址，然后还要部分写 <code>bk</code> 使其落在 <code>tcache_perthread_struct</code> 区域。其他步骤一样。</p>
<p>或者，在 <code>smallbin</code> 里面放 <code>9</code> 个，这样第 <code>8</code> 个的 <code>bk</code> 肯定就是一个堆地址。此时就需要爆破 <code>1/16</code> 的堆，<code>1/16</code> 的 <code>glibc</code> 地址，成功的概率是 <code>1/256</code>。</p>
<h3 id="相关技巧-16">相关技巧
</h3><ul>
<li>总的来说，就是利用 <code>tcachebin stash unlinking</code> 打 <code>tcache_perthread_struct</code></li>
<li>利用 <code>largebin attack</code> 构造合法地址</li>
</ul>
<h3 id="利用效果-16">利用效果
</h3><ul>
<li>任意地址分配</li>
<li>任意函数执行</li>
</ul>
<h2 id="218-house-of-crust">2.18-House of Crust
</h2><h3 id="漏洞成因-17">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-17">适用范围
</h3><ul>
<li><code>2.26</code>——<code>2.37</code></li>
<li>可以进行 <code>tcache stash unlinking</code> 攻击</li>
<li>可以进行 <code>largebin attack</code></li>
<li>不需要泄露地址</li>
</ul>
<h3 id="利用原理-17">利用原理
</h3><p>其他步骤和上面的 <code>house of rust</code> 一样，但是到第五步的时候，去修改 <code>global_max_fast</code></p>
<p>后面的步骤和 <code>house of corrosion</code> 是一样的，通过写原语打 <code>stderr</code> 修改 <code>one_gadget</code> 拿到 <code>shell</code>。</p>
<h3 id="相关技巧-17">相关技巧
</h3><ul>
<li><code>house of crust = house of corrosion + house of rust</code></li>
<li><code>2.37</code> 之后，<code>house of corrosion</code> 使用受限</li>
</ul>
<h2 id="219-house-of-io">2.19-House of Io
</h2><h3 id="漏洞成因-18">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-18">适用范围
</h3><ul>
<li><code>2.26</code>—— 至今</li>
</ul>
<h3 id="利用原理-18">利用原理
</h3><p>其他博客上对该方法的介绍如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">The</span> <span class="n">tcache_perthread_object</span> <span class="n">is</span> <span class="n">allocated</span> <span class="n">when</span> <span class="n">the</span> <span class="n">heap</span> <span class="n">is</span> <span class="n">created</span><span class="p">.</span> <span class="n">Furthermore</span><span class="p">,</span> <span class="n">it</span> <span class="n">is</span> <span class="n">stored</span> <span class="n">right</span> <span class="n">at</span> <span class="n">the</span> <span class="n">heap</span><span class="err">&#39;</span><span class="n">s</span> <span class="nf">beginning</span> <span class="p">(</span><span class="n">at</span> <span class="n">a</span> <span class="n">relatively</span> <span class="n">low</span> <span class="n">memory</span> <span class="n">address</span><span class="p">).</span> <span class="n">The</span> <span class="n">safe</span><span class="o">-</span><span class="n">linking</span> <span class="n">mitigation</span> <span class="n">aims</span> <span class="n">to</span> <span class="n">protect</span> <span class="n">the</span> <span class="n">fd</span><span class="o">/</span><span class="n">next</span> <span class="n">pointer</span> <span class="n">within</span> <span class="n">the</span> <span class="n">free</span> <span class="n">lists</span><span class="p">.</span> <span class="n">However</span><span class="p">,</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="n">each</span> <span class="n">free</span><span class="o">-</span><span class="n">list</span> <span class="n">is</span> <span class="n">not</span> <span class="n">protected</span><span class="p">.</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">freeing</span> <span class="n">a</span> <span class="n">chunk</span> <span class="n">and</span> <span class="n">placing</span> <span class="n">it</span> <span class="n">into</span> <span class="n">the</span> <span class="n">tcachebin</span> <span class="n">also</span> <span class="n">places</span> <span class="n">a</span> <span class="n">non</span><span class="o">-</span><span class="n">protected</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">appropriate</span> <span class="n">tcache</span> <span class="n">entry</span> <span class="n">in</span> <span class="n">the</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">qword</span> <span class="n">of</span> <span class="n">a</span> <span class="n">chunks</span><span class="err">&#39;</span> <span class="n">user</span> <span class="n">data</span><span class="p">.</span> <span class="n">The</span> <span class="n">House</span> <span class="n">of</span> <span class="n">IO</span> <span class="n">assumes</span> <span class="n">one</span> <span class="n">of</span> <span class="n">three</span> <span class="n">scenarios</span> <span class="k">for</span> <span class="n">the</span> <span class="n">bypass</span> <span class="n">to</span> <span class="n">work</span><span class="p">.</span> <span class="n">First</span><span class="p">,</span> <span class="n">any</span> <span class="n">attacker</span> <span class="n">with</span> <span class="n">a</span> <span class="n">controlled</span> <span class="n">linear</span> <span class="n">buffer</span> <span class="n">underflow</span> <span class="n">over</span> <span class="n">a</span> <span class="n">heap</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">or</span> <span class="n">a</span> <span class="n">relative</span> <span class="n">arbitrary</span> <span class="n">write</span> <span class="n">will</span> <span class="n">be</span> <span class="n">able</span> <span class="n">to</span> <span class="n">corrupt</span> <span class="n">the</span> <span class="n">tcache</span><span class="p">.</span> <span class="n">Secondly</span><span class="p">,</span> <span class="n">a</span> <span class="n">UAF</span> <span class="n">bug</span> <span class="n">allowing</span> <span class="n">to</span> <span class="n">read</span> <span class="n">from</span> <span class="n">a</span> <span class="n">freed</span> <span class="n">tcache</span> <span class="n">eligible</span> <span class="n">chunk</span> <span class="n">leaks</span> <span class="n">the</span> <span class="n">tcache</span> <span class="n">and</span> <span class="n">with</span> <span class="n">that</span><span class="p">,</span> <span class="n">the</span> <span class="n">heap</span> <span class="n">base</span><span class="p">.</span> <span class="n">Thirdly</span><span class="p">,</span> <span class="n">a</span> <span class="n">badly</span> <span class="n">ordered</span> <span class="n">set</span> <span class="n">of</span> <span class="n">calls</span> <span class="n">to</span> <span class="nf">free</span><span class="p">(),</span> <span class="n">ultimately</span> <span class="n">passing</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">tcache</span> <span class="n">itself</span> <span class="n">to</span> <span class="n">free</span><span class="p">,</span> <span class="n">would</span> <span class="n">link</span> <span class="n">the</span> <span class="n">tcache</span> <span class="n">into</span> <span class="n">the</span> <span class="mh">0x290</span> <span class="n">sized</span> <span class="n">tcachebin</span><span class="p">.</span> <span class="n">Allocating</span> <span class="n">it</span> <span class="n">as</span> <span class="n">a</span> <span class="n">new</span> <span class="n">chunk</span> <span class="n">would</span> <span class="n">mean</span> <span class="n">complete</span> <span class="n">control</span> <span class="n">over</span> <span class="n">the</span> <span class="n">tcache</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">values</span><span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出来，其实就是对 <code>tcache_perthread_struct</code> 结构体的攻击，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个 <code>tcache</code> 的分配。</p>
<h3 id="相关技巧-18">相关技巧
</h3><ul>
<li>围绕 <code>tcache_perthread_struct</code> 进行攻击</li>
</ul>
<h3 id="利用效果-17">利用效果
</h3><ul>
<li>任意地址分配</li>
</ul>
<h2 id="220-house-of-banana">2.20-House of Banana
</h2><h3 id="漏洞成因-19">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-19">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以进行 <code>largebin attack</code></li>
<li>能执行 <code>exit</code> 函数</li>
</ul>
<h3 id="利用原理-19">利用原理
</h3><p>首先是 <code>largebin attack</code> 在高版本只能从下面这个分支利用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* maintain large bins in sorted order */</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">fwd</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="cm">/* Or with inuse bit to speed comparisons */</span>
</span></span><span class="line"><span class="cl">                  <span class="n">size</span> <span class="o">|=</span> <span class="n">PREV_INUSE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="cm">/* if smaller than smallest, bypass loop below */</span>
</span></span><span class="line"><span class="cl">                  <span class="nf">assert</span> <span class="p">(</span><span class="nf">chunk_main_arena</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		      <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="nf">chunksize_nomask</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                      <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">bck</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                      <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                  <span class="k">else</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                      <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也就是，双链表里面至少存在一个 <code>largebin chunk</code>，且目前要入链的 <code>chunk</code> 比最小的还小，修改了 <code>bk_nextsize</code> 之后就会触发。可以造成任意地址写堆地址。</p>
<p>然后是 <code>exit</code> 调用的时候，会调用到<code>_dl_fini</code> 函数，执行每个 <code>so</code> 中注册的 <code>fini</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmaps</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_init_called</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Make sure nothing happens if we are called twice.  */</span>
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_init_called</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Is there a destructor function?  */</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI_ARRAY</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span>
</span></span><span class="line"><span class="cl">            <span class="o">||</span> <span class="p">(</span><span class="n">ELF_INITFINI</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* When debugging print a message first.  */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">__builtin_expect</span> <span class="p">(</span><span class="nf">GLRO</span><span class="p">(</span><span class="n">dl_debug_mask</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                  <span class="o">&amp;</span> <span class="n">DL_DEBUG_IMPCALLS</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="nf">_dl_debug_printf</span> <span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">calling fini: %s [%lu]</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="nf">DSO_FILENAME</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_name</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">ns</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* First see whether an array is given.  */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI_ARRAY</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                    <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span>
</span></span><span class="line"><span class="cl">                                    <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI_ARRAY</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI_ARRAYSZ</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_val</span>
</span></span><span class="line"><span class="cl">                                  <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="nf">ElfW</span><span class="p">(</span><span class="n">Addr</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">                <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">((</span><span class="kt">fini_t</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">();</span> <span class="c1">// 这里call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="cm">/* Next try the old-style destructor.  */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ELF_INITFINI</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">DL_CALL_DT_FINI</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_addr</span> <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_info</span><span class="p">[</span><span class="n">DT_FINI</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">d_un</span><span class="p">.</span><span class="n">d_ptr</span><span class="p">);</span> <span class="c1">// 这里call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以触发 <code>call</code> 的有两个点，第一个点可以 <code>call</code> 到很多指针，是一个数组；另一个点就只有一个函数。</p>
<p>剩下的工作就是根据代码绕过检测，调用到调用点。</p>
<p>所以，利用的思路有：</p>
<ul>
<li>直接伪造<code>_rtld_global</code> 的<code>_ns_loaded</code>，布局好其他内容，使其调用到 <code>fini_array</code></li>
<li>伪造 <code>link_map</code> 的 <code>next</code> 指针，布局好其他内容，使其调用到 <code>fini_array</code></li>
<li>修改 <code>link_map-&gt;l_addr</code>，根据偏移使其调用到指定区域的函数</li>
</ul>
<h3 id="相关技巧-19">相关技巧
</h3><ul>
<li>伪造 <code>fini_array</code> 数组的时候，是从后往前遍历的</li>
<li>有时候远程的 <code>rtld_global</code> 的偏移与本地不一样，需要爆破</li>
<li>如果不想逐个伪造，可以直接用 <code>gdb</code> 从内存里面 <code>dump</code> 出来，然后基于偏移修改内存即可</li>
</ul>
<h3 id="利用效果-18">利用效果
</h3><ul>
<li>任意代码执行</li>
</ul>
<h2 id="221-house-of-kiwi">2.21-House of Kiwi
</h2><h3 id="漏洞成因-20">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-20">适用范围
</h3><ul>
<li><code>2.23</code>——<code>2.36</code></li>
<li>在 <code>malloc</code> 流程中触发 <code>assert</code></li>
</ul>
<h3 id="利用原理-20">利用原理
</h3><p>主要是提供了一种在程序中调用 <code>IO</code> 流函数的思路：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#if IS_IN (libc)
</span></span></span><span class="line"><span class="cl"><span class="cp">#ifndef NDEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"># define __assert_fail(assertion, file, line, function)			
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	 <span class="nf">__malloc_assert</span><span class="p">(</span><span class="n">assertion</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__progname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">__malloc_assert</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">assertion</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">__fxprintf</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&#34;%s%s%s:%u: %s%sAssertion `%s&#39; failed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		     <span class="n">__progname</span><span class="p">,</span> <span class="n">__progname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="s">&#34;: &#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		     <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		     <span class="n">function</span> <span class="o">?</span> <span class="nl">function</span> <span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="n">function</span> <span class="o">?</span> <span class="s">&#34;: &#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		     <span class="n">assertion</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fflush</span> <span class="p">(</span><span class="n">stderr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">abort</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，调用到了 <code>fxprintf</code> 和 <code>fflush</code>。</p>
<p>至于原 <code>house of kiwi</code> 所提到的控制 <code>rdx</code> 的思路，在很多版本中无法使用，因为 <code>IO_jumps_table</code> 都是不可写的，故此处不再详述。</p>
<h3 id="相关技巧-20">相关技巧
</h3><ul>
<li>在 <code>2.36</code> 之后，<code>__malloc_assert</code> 被修改为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">_Noreturn</span> <span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">__malloc_assert</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">assertion</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">__libc_message</span> <span class="p">(</span><span class="n">do_abort</span><span class="p">,</span> <span class="s">&#34;\
</span></span></span><span class="line"><span class="cl"><span class="s">Fatal glibc error: malloc assertion failure in %s: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		  <span class="n">function</span><span class="p">,</span> <span class="n">assertion</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">__builtin_unreachable</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而在 <code>2.37</code> 该函数直接被删掉了。</p>
<ul>
<li>如果 <code>stderr</code> 在 <code>libc</code> 上，需要修改调 <code>stderr</code> 处的指针，也有可能在程序的地址空间上</li>
<li>伪造的技巧如下，触发 <code>fxprintf(stderr，......)</code>：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">flags &amp; 0x8000的话，不用伪造_lock
</span></span><span class="line"><span class="cl">flags &amp; ~(0x2 | 0x8) 必须成立，避免走到unbuffered的流程
</span></span><span class="line"><span class="cl">mode 设置为0
</span></span><span class="line"><span class="cl">vtable默认调用的是偏移0x38的函数，如果想劫持为_IO_xxx_overflow，需要设置为_IO_xxx_jumps-0x20
</span></span><span class="line"><span class="cl">flags 可以设置为&#34;  sh||&#34;，前面有两个空格，此时还需要设置_lock，不想设置_lock的时候，flags可以为&#34;\x20\x80;sh||&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="利用效果-19">利用效果
</h3><ul>
<li>触发 <code>IO</code> 处理流程，为后续利用做准备</li>
</ul>
<h2 id="222-house-of-emma">2.22-House of Emma
</h2><h3 id="漏洞成因-21">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-21">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以进行两次 <code>largebin attack</code></li>
<li>或者可以进行两次任意地址写堆地址</li>
<li>可以触发 <code>IO</code> 流操作</li>
</ul>
<h3 id="利用原理-21">利用原理
</h3><p>在<code>_IO_cookie_jumps</code> 中存在一些<code>_IO_cookie_read</code> 等函数，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">ssize_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">_IO_cookie_read</span> <span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">_IO_cookie_file</span> <span class="o">*</span><span class="n">cfile</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_IO_cookie_file</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">cookie_read_function_t</span> <span class="o">*</span><span class="n">read_cb</span> <span class="o">=</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">__io_functions</span><span class="p">.</span><span class="n">read</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef PTR_DEMANGLE
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nf">PTR_DEMANGLE</span> <span class="p">(</span><span class="n">read_cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">read_cb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">read_cb</span> <span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">__cookie</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到有函数指针的调用。但是对函数指针使用 <code>pointer_guard</code> 进行了加密：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#  define PTR_MANGLE(var)	asm (&#34;xorl %%gs:%c2, %0\n&#34;		      \
</span></span></span><span class="line"><span class="cl"><span class="cp">				     &#34;roll $9, %0&#34;			      \
</span></span></span><span class="line"><span class="cl"><span class="cp">				     : &#34;=r&#34; (var)			      \
</span></span></span><span class="line"><span class="cl"><span class="cp">				     : &#34;0&#34; (var),			      \
</span></span></span><span class="line"><span class="cl"><span class="cp">				       &#34;i&#34; (offsetof (tcbhead_t,	      \
</span></span></span><span class="line"><span class="cl"><span class="cp">						      pointer_guard)))
</span></span></span><span class="line"><span class="cl"><span class="cp">#  define PTR_DEMANGLE(var)	asm (&#34;rorl $9, %0\n&#34;			      \
</span></span></span><span class="line"><span class="cl"><span class="cp">				     &#34;xorl %%gs:%c2, %0&#34;		      \
</span></span></span><span class="line"><span class="cl"><span class="cp">				     : &#34;=r&#34; (var)			      \
</span></span></span><span class="line"><span class="cl"><span class="cp">				     : &#34;0&#34; (var),			      \
</span></span></span><span class="line"><span class="cl"><span class="cp">				       &#34;i&#34; (offsetof (tcbhead_t,	      \
</span></span></span><span class="line"><span class="cl"><span class="cp">						      pointer_guard)))
</span></span></span><span class="line"><span class="cl"><span class="cp"># endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>循环右移后，再异或。</p>
<p>因此，利用思路如下：</p>
<ul>
<li>截至某个 <code>IO_FILE</code> 的指针（<code>IO_list_all/stdxxx-&gt;chain</code> 等都可以）为堆地址</li>
<li>堆上伪造 <code>IO_FILE</code> 结构，其 <code>vtable</code> 替换为<code>_IO_cookie_jumps+XX</code>，<code>XX</code> 为一个偏移量</li>
<li>伪造好函数指针和调用参数，指针需要循环异或和加密</li>
<li>调用到<code>_IO_cookie_read</code> 等函数，进而执行任意函数</li>
</ul>
<h3 id="相关技巧-21">相关技巧
</h3><ul>
<li>常用的 <code>gadget</code> 有：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">;栈迁移
</span></span><span class="line"><span class="cl">mov    rbp,QWORD PTR [rdi+0x48]
</span></span><span class="line"><span class="cl">mov    rax,QWORD PTR [rbp+0x18]
</span></span><span class="line"><span class="cl">lea    r13,[rbp+0x10]
</span></span><span class="line"><span class="cl">mov    DWORD PTR [rbp+0x10],0x0
</span></span><span class="line"><span class="cl">mov    rdi,r13
</span></span><span class="line"><span class="cl">call   QWORD PTR [rax+0x28]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">; rdi转rdx
</span></span><span class="line"><span class="cl">mov rdx, qword ptr [rdi + 8]
</span></span><span class="line"><span class="cl">mov qword ptr [rsp], rax
</span></span><span class="line"><span class="cl">call qword ptr [rdx + 0x20]
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>pointer_guard</code> 就在 <code>canary</code> 下面，偏移可能需要爆破</li>
</ul>
<h3 id="利用效果-20">利用效果
</h3><ul>
<li>任意函数执行</li>
</ul>
<h2 id="223-house-of-pig">2.23-House of Pig
</h2><h3 id="漏洞成因-22">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-22">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以进行 <code>largebin attack</code></li>
<li>可以触发 <code>IO</code> 流操作</li>
</ul>
<h3 id="利用原理-22">利用原理
</h3><p>在<code>_IO_str_jumps</code> 中，存在着<code>_IO_str_overflow</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">_IO_str_overflow</span> <span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">flush_only</span> <span class="o">=</span> <span class="n">c</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_NO_WRITES</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">flush_only</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">EOF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_TIED_PUT_GET</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_CURRENTLY_PUTTING</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_CURRENTLY_PUTTING</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pos</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="p">(</span><span class="nf">_IO_blen</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">+</span> <span class="n">flush_only</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_USER_BUF</span><span class="p">)</span> <span class="cm">/* not allowed to enlarge */</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="kt">char</span> <span class="o">*</span><span class="n">new_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="kt">char</span> <span class="o">*</span><span class="n">old_buf</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span> <span class="c1">// 覆盖到这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	  <span class="kt">size_t</span> <span class="n">old_blen</span> <span class="o">=</span> <span class="nf">_IO_blen</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	  <span class="kt">size_t</span> <span class="n">new_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">old_blen</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;</span> <span class="n">old_blen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	    <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	  <span class="n">new_buf</span> <span class="o">=</span> <span class="nf">malloc</span> <span class="p">(</span><span class="n">new_size</span><span class="p">);</span> <span class="c1">// 调用malloc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	  <span class="k">if</span> <span class="p">(</span><span class="n">new_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	    <span class="p">{</span>
</span></span><span class="line"><span class="cl">	      <span class="cm">/*	  __ferror(fp) = 1; */</span>
</span></span><span class="line"><span class="cl">	      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	  <span class="k">if</span> <span class="p">(</span><span class="n">old_buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	    <span class="p">{</span>
</span></span><span class="line"><span class="cl">	      <span class="nf">memcpy</span> <span class="p">(</span><span class="n">new_buf</span><span class="p">,</span> <span class="n">old_buf</span><span class="p">,</span> <span class="n">old_blen</span><span class="p">);</span><span class="c1">// 调用memecpy，覆盖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	      <span class="nf">free</span> <span class="p">(</span><span class="n">old_buf</span><span class="p">);</span> <span class="c1">// 调用free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	      <span class="cm">/* Make sure _IO_setb won&#39;t try to delete _IO_buf_base. */</span>
</span></span><span class="line"><span class="cl">	      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	  <span class="nf">memset</span> <span class="p">(</span><span class="n">new_buf</span> <span class="o">+</span> <span class="n">old_blen</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">new_size</span> <span class="o">-</span> <span class="n">old_blen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从函数中就能看到，利用流程如下：</p>
<ul>
<li>伪造 <code>IO_FILE</code> 的<code>_IO_buf_base</code></li>
<li>合理控制<code>_IO_buf_end-_IO_buf_base</code> 的值，进而控制分配的 <code>chunk</code> 的大小，分配到布局好的地址</li>
<li>在 <code>memcpy</code> 中覆盖地址，如可以覆盖<code>__malloc_hook/__free_hook</code> 等</li>
</ul>
<p>该方法需要结合其他堆利用技术，需要保证 <code>malloc</code> 分配出来的 <code>chunk</code> 的地址是可控的。该方法主要提供了对 <code>IO</code> 系列函数中间接调用 <code>mallc/free/memcpy</code> 的组合利用。</p>
<h3 id="相关技巧-22">相关技巧
</h3><ul>
<li>可以 <code>largebin attack</code> 打掉 <code>mp_.tcachebins</code>，进而能把很大的 <code>chunk</code> 也放进入 <code>tcache</code> 进行管理</li>
<li>高版本没有 <code>hook</code> 的话，可以利用 <code>memcpy@got</code>，通过覆写 <code>got</code> 来进行 <code>rce</code></li>
<li>可以多次 <code>house of pig</code> 组合调用</li>
</ul>
<h3 id="利用效果-21">利用效果
</h3><ul>
<li>任意函数执行</li>
<li><code>ROP</code> 控制程序执行流</li>
</ul>
<h2 id="224-house-of-obstack">2.24-House of Obstack
</h2><h3 id="漏洞成因-23">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-23">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以执行一次 <code>largebin attack</code></li>
<li>可以触发 <code>IO</code> 流操作</li>
</ul>
<h3 id="利用原理-23">利用原理
</h3><p>一条新的利用链，伪造 <code>vtable</code> 为<code>_IO_obstack_jumps</code>，然后调用到<code>_IO_obstack_xsputn</code>，紧接着调用 <code>obstack_grow</code>，其代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define obstack_grow(OBSTACK, where, length)                      \
</span></span></span><span class="line"><span class="cl"><span class="cp">  __extension__                                   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    ({ struct obstack *__o = (OBSTACK);                       \
</span></span></span><span class="line"><span class="cl"><span class="cp">       int __len = (length);                              \
</span></span></span><span class="line"><span class="cl"><span class="cp">       if (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">     _obstack_newchunk (__o, __len);                      \
</span></span></span><span class="line"><span class="cl"><span class="cp">       memcpy (__o-&gt;next_free, where, __len);                     \
</span></span></span><span class="line"><span class="cl"><span class="cp">       __o-&gt;next_free += __len;                           \
</span></span></span><span class="line"><span class="cl"><span class="cp">       (void) 0; })
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后在<code>_obstack_newchunk</code> 调用了 <code>CALL_CHUNKFUN</code> 这个宏</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">_obstack_newchunk</span> <span class="p">(</span><span class="k">struct</span> <span class="n">obstack</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">_obstack_chunk</span> <span class="o">*</span><span class="n">old_chunk</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">chunk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">_obstack_chunk</span> <span class="o">*</span><span class="n">new_chunk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">new_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">obj_size</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next_free</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">object_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">long</span> <span class="n">already</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">object_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Compute size for new chunk.  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">new_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj_size</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">obj_size</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">alignment_mask</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_size</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">chunk_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Allocate and initialize the new chunk.  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">new_chunk</span> <span class="o">=</span> <span class="nf">CALL_CHUNKFUN</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">[...]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个宏会调用到函数指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp"># define CALL_CHUNKFUN(h, size) \
</span></span></span><span class="line"><span class="cl"><span class="cp">  (((h)-&gt;use_extra_arg)                               \
</span></span></span><span class="line"><span class="cl"><span class="cp">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))                     \
</span></span></span><span class="line"><span class="cl"><span class="cp">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此，其就是利用该函数指针进行控制程序的执行流。</p>
<h3 id="相关技巧-23">相关技巧
</h3><p>伪造的 <code>IO_FILE</code> 布局如下：</p>
<ul>
<li>利用 <code>largebin attack</code> 伪造<code>_IO_FILE</code>，记完成伪造的 <code>chunk</code> 为 <code>A</code>（或者别的手法）</li>
<li><code>chunk A</code> 内偏移为 <code>0xd8</code> 处设为<code>_IO_obstack_jumps+0x20</code></li>
<li><code>chunk A</code> 内偏移为 <code>0xe0</code> 处设置 <code>chunk A</code> 的地址作为 <code>obstack</code> 结构体</li>
<li><code>chunk A</code> 内偏移为 <code>0x18</code> 处设为 <code>1</code>（<code>next_free</code>)</li>
<li><code>chunk A</code> 内偏移为 <code>0x20</code> 处设为 <code>0</code>（<code>chunk_limit</code>）</li>
<li><code>chunk A</code> 内偏移为 <code>0x48</code> 处设为 <code>&amp;/bin/sh</code></li>
<li><code>chunk A</code> 内偏移为 <code>0x38</code> 处设为 <code>system</code> 函数的地址</li>
<li><code>chunk A</code> 内偏移为 <code>0x28</code> 处设为 <code>1</code>（<code>_IO_write_ptr</code>)</li>
<li><code>chunk A</code> 内偏移为 <code>0x30</code> 处设为 <code>0</code> (<code>_IO_write_end</code>)</li>
<li><code>chunk A</code> 内偏移为 <code>0x50</code> 处设为 <code>1</code> (<code>use_extra_arg</code>)</li>
</ul>
<p><code>glibc-2.37</code> 开始这个方法的调用链为：<code>__printf_buffer_as_file_overflow -&gt; __printf_buffer_flush -&gt; __printf_buffer_flush_obstack-&gt;__obstack_newchunk</code>。</p>
<h3 id="利用效果-22">利用效果
</h3><ul>
<li>任意函数执行</li>
</ul>
<h2 id="225-house-of-apple1">2.25-House of Apple1
</h2><h3 id="漏洞成因-24">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-24">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>程序从 <code>main</code> 函数返回或能调用 <code>exit</code> 函数</li>
<li>能泄露出 <code>heap</code> 地址和 <code>libc</code> 地址</li>
<li>能使用一次 <code>largebin attack</code>（一次即可）</li>
</ul>
<h3 id="利用原理-24">利用原理
</h3><p>利用<code>_IO_wstr_overflow</code> 将任意地址存储的值修改已知值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">wint_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">_IO_wstrn_overflow</span> <span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">wint_t</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* When we come to here this means the user supplied buffer is
</span></span></span><span class="line"><span class="cl"><span class="cm">     filled.  But since we must return the number of characters which
</span></span></span><span class="line"><span class="cl"><span class="cm">     would have been written in total we must provide a buffer for
</span></span></span><span class="line"><span class="cl"><span class="cm">     further use.  We can do this by writing on and on in the overflow
</span></span></span><span class="line"><span class="cl"><span class="cm">     buffer in the _IO_wstrnfile structure.  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">_IO_wstrnfile</span> <span class="o">*</span><span class="n">snf</span> <span class="o">=</span> <span class="p">(</span><span class="n">_IO_wstrnfile</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">!=</span> <span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">_IO_wsetb</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		 <span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				      <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">wchar_t</span><span class="p">)),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span>
</span></span><span class="line"><span class="cl">				      <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					 <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">wchar_t</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span> <span class="o">=</span> <span class="n">snf</span><span class="o">-&gt;</span><span class="n">overflow_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Since we are not really interested in storing the characters
</span></span></span><span class="line"><span class="cl"><span class="cm">     which do not fit in the buffer we simply ignore it.  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如修改 <code>tcache</code> 变量、<code>mp_</code>结构体、<code>pointer_guard</code> 变量等。</p>
<p>修改成功后，再使用其他技术控制程序执行流。</p>
<h3 id="相关技巧-24">相关技巧
</h3><p><code>house of apple1</code> 是对现有一些 <code>IO</code> 流攻击方法的补充，能在一次劫持 <code>IO</code> 流的过程中做到任意地址写已知值，进而构造出其他方法攻击成功的条件。</p>
<h3 id="利用效果-23">利用效果
</h3><ul>
<li>任意地址写已知堆地址</li>
</ul>
<h2 id="226-house-of-apple2">2.26-House of Apple2
</h2><h3 id="漏洞成因-25">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-25">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>已知 <code>heap</code> 地址和 <code>glibc</code> 地址</li>
<li>能控制程序执行 <code>IO</code> 操作，包括但不限于：从 <code>main</code> 函数返回、调用 <code>exit</code> 函数、通过<code>__malloc_assert</code> 触发</li>
<li>能控制<code>_IO_FILE</code> 的 <code>vtable</code> 和<code>_wide_data</code>，一般使用 <code>largebin attack</code> 去控制</li>
</ul>
<h3 id="利用原理-25">利用原理
</h3><p><code>_IO_WIDE_JUMPS</code> 没有检查<code>_wide_vtable</code> 的合法性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define _IO_WIDE_JUMPS(THIS) \
</span></span></span><span class="line"><span class="cl"><span class="cp">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>所以利用<code>_IO_wfile_jumps</code> 等伪造<code>_wide_vtable</code> 即可。</p>
<h3 id="相关技巧-25">相关技巧
</h3><p>利用<code>_IO_wfile_overflow</code> 函数控制程序执行流时对 <code>fp</code> 的设置如下：</p>
<ul>
<li><code>_flags</code> 设置为 <code>~(2 | 0x8 | 0x800)</code>，如果不需要控制 <code>rdi</code>，设置为 <code>0</code> 即可；如果需要获得 <code>shell</code>，可设置为<code> sh;</code>，注意前面有两个空格</li>
<li><code>vtable</code> 设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code> 地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code> 即可</li>
<li><code>_wide_data</code> 设置为可控堆地址 <code>A</code>，即满足 <code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code>，即满足 <code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code>，即满足 <code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code> 设置为可控堆地址 <code>B</code>，即满足 <code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> 设置为地址 <code>C</code> 用于劫持 <code>RIP</code>，即满足 <code>*(B + 0x68) = C</code></li>
</ul>
<h3 id="利用效果-24">利用效果
</h3><ul>
<li>任意函数执行</li>
</ul>
<h2 id="227-house-of-apple3">2.27-House of Apple3
</h2><h3 id="漏洞成因-26">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-26">适用范围
</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>已知 <code>heap</code> 地址和 <code>glibc</code> 地址</li>
<li>能控制程序执行 <code>IO</code> 操作，包括但不限于：从 <code>main</code> 函数返回、调用 <code>exit</code> 函数、通过<code>__malloc_assert</code> 触发</li>
<li>能控制<code>_IO_FILE</code> 的 <code>vtable</code> 和<code>_wide_data</code>，一般使用 <code>largebin attack</code> 去控制</li>
</ul>
<h3 id="利用原理-26">利用原理
</h3><p><code>__libio_codecvt_in</code> 等函数，可以设置 <code>gs-&gt;__shlib_handle == NULL</code> 绕过 <code>PTR_DEMANGLE</code> 对指针的保护，然后通过<code>_IO_wfile_underflow </code>调用到<code>__libio_codecvt_in</code> 来控制函数指针，执行任意代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">__codecvt_result</span>
</span></span><span class="line"><span class="cl"><span class="nf">__libio_codecvt_in</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">codecvt</span><span class="p">,</span> <span class="n">__mbstate_t</span> <span class="o">*</span><span class="n">statep</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_start</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		    <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">from_stop</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		    <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">to_start</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">to_end</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">**</span><span class="n">to_stop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="n">__codecvt_result</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// gs 源自第一个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="n">__gconv_step</span> <span class="o">*</span><span class="n">gs</span> <span class="o">=</span> <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">dummy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from_start_copy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__outbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">to_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__outbufend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">to_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">.</span><span class="n">__statep</span> <span class="o">=</span> <span class="n">statep</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">__gconv_fct</span> <span class="n">fct</span> <span class="o">=</span> <span class="n">gs</span><span class="o">-&gt;</span><span class="n">__fct</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef PTR_DEMANGLE
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="c1">// 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 这里如果可控，设置为NULL即可绕过解密
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">gs</span><span class="o">-&gt;</span><span class="n">__shlib_handle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">PTR_DEMANGLE</span> <span class="p">(</span><span class="n">fct</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="c1">// 这里有函数指针调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 这个宏就是调用fct(gs, ...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">status</span> <span class="o">=</span> <span class="nf">DL_CALL_FCT</span> <span class="p">(</span><span class="n">fct</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codecvt</span><span class="o">-&gt;</span><span class="n">__cd_in</span><span class="p">.</span><span class="n">step_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from_start_copy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			 <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">from_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			 <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="相关技巧-26">相关技巧
</h3><p>利用_IO_wfile_underflow 函数控制程序执行流时对 <code>fp</code> 的设置如下：</p>
<ul>
<li><code>_flags</code> 设置为 <code>~(4 | 0x10)</code></li>
<li><code>vtable</code> 设置为<code>_IO_wfile_jumps</code> 地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code> 即可</li>
<li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足 <code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code> 保持默认，或者设置为堆地址，假设其地址为 <code>A</code>，即满足 <code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足 <code>*A &gt;= *(A + 8)</code></li>
<li><code>_codecvt</code> 设置为可控堆地址 <code>B</code>，即满足 <code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code> 设置为可控堆地址 <code>C</code>，即满足 <code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code> 设置为 <code>0</code>，即满足 <code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code> 设置为地址 <code>D</code>, 地址 <code>D</code> 用于控制 <code>rip</code>，即满足 <code>*(C + 0x28) = D</code>。当调用到 <code>D</code> 的时候，此时的 <code>rdi</code> 为 <code>C</code>。如果<code>_wide_data</code> 也可控的话，<code>rsi</code> 也能控制。</li>
</ul>
<h3 id="利用效果-25">利用效果
</h3><ul>
<li>任意函数执行</li>
</ul>
<h2 id="228-house-of-gods">2.28-House of Gods
</h2><h3 id="漏洞成因-27">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-27">适用范围
</h3><ul>
<li><code>2.23</code>——<code>2.27</code></li>
<li>泄露堆地址和 <code>libc</code> 地址</li>
<li>任意大小分配</li>
</ul>
<h3 id="利用原理-27">利用原理
</h3><p>这个技巧比较有意思，非常建议把作者的原博客读一下。我会简述一下该技巧的利用过程。</p>
<p>总的来说，该技巧最终的目的是伪造一个 <code>fake arena</code>，通过劫持 <code>main_arena.next</code> 字段完成。</p>
<p>其主要过程为：</p>
<ul>
<li>通过 <code>binmap</code> 的赋值，将其当做 <code>chunk</code> 的 <code>size</code>，然后修改 <code>unsortedbin</code> 链的 <code>bk</code> 指向 <code>binmap</code>，作者选择的是 <code>0x90</code> 大小的 <code>chunk</code>，释放后恰好让 <code>binmap</code> 称为 <code>0x200</code>，然后 <code>binmap-&gt;bk</code> 是 <code>main_arena</code>(初始状态下 <code>main_arena.next = &amp;main_arena</code>)，然后 <code>main_arena-&gt;bk= fastbin[0x40]</code></li>
<li>分配 <code>0x1f0</code> 大小的 <code>chunk</code> 就刚好能分配到 <code>binmap</code></li>
<li>之后修改掉 <code>main_arena</code> 的 <code>system_mem</code> 为很大的值和 <code>next</code> 指向 <code>fake arena</code></li>
<li>然后用 <code>unsortedbin attack</code> 打掉 <code>narenas</code>，将其改为一个很大的数</li>
<li>然后分配两次 <code>malloc(0xffffffffffffffbf + 1)</code>，触发 <code>arena_get_retry</code>，进而触发两次 <code>reused_arena</code>，就能把 <code>fake arena</code> 给 <code>thread_arena</code> 变量</li>
<li>最后直接伪造 <code>fastbin</code> 任意地址分配</li>
</ul>
<h3 id="相关技巧-27">相关技巧
</h3><ul>
<li>仅仅借助 <code>unsortedbin</code> 链就能控制 <code>main_arena</code> 的 <code>next</code> 和 <code>system_mem</code></li>
<li>利用 <code>binmap</code> 的值构造出合法的 <code>size</code></li>
</ul>
<h3 id="利用效果-26">利用效果
</h3><ul>
<li>劫持 <code>thread_arena</code> 为 <code>fake_arena</code></li>
</ul>
<h2 id="229-house-of-lys">2.29-House of Lys
</h2><h3 id="漏洞成因-28">漏洞成因
</h3><p>堆溢出</p>
<h3 id="适用范围-28">适用范围
</h3><ul>
<li><code>2.23</code> —— 至今</li>
<li>泄露堆地址和 <code>libc</code> 地址</li>
<li>任意大小分配</li>
</ul>
<h3 id="利用原理-28">利用原理
</h3><p>调用 <code>_IO_obstack_XXX</code> 函数的时候，没有检查函数指针的有效性。调用链为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">exit
</span></span><span class="line"><span class="cl"> __run_exit_handlers
</span></span><span class="line"><span class="cl">   fcloseall
</span></span><span class="line"><span class="cl">     _IO_cleanup
</span></span><span class="line"><span class="cl">		_IO_flush_all_lockp
</span></span><span class="line"><span class="cl">     		_IO_obstack_xsputn
</span></span><span class="line"><span class="cl">         		obstack_grow
</span></span><span class="line"><span class="cl">           			_obstack_newchunk
</span></span><span class="line"><span class="cl">              			CALL_CHUNKFUN(一个宏定义)
</span></span><span class="line"><span class="cl">                			(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="3---总结">3 - 总结
</h2><ul>
<li>总结了 <code>30</code> 种 <code>house of</code> 系列利用手法</li>
<li>给出了每种利用手法的影响版本、适用范围、利用原理等</li>
<li>所有的利用方法都可以在源码中找到答案，因此强烈建议将源码反复阅读</li>
<li>可以根据目前已有的技术提出新的组合技</li>
</ul>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2026 A1ester@Luigi
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<script>
  const cdnPath = "https://cdn.meimolihan.eu.org/hugo/live2d";
  

  const config = {
    
    path: {
      homePath: "/",
      modelPath: cdnPath + "/live2d-moc3/",
      cssPath: cdnPath + "/waifu.css",
      tipsJsonPath: cdnPath + "/waifu-tips.json",
      tipsJsPath: cdnPath + "/waifu-tips.js",
      live2dCorePath: cdnPath + "/live2dcubismcore.js",
      live2dSdkPath: cdnPath + "/live2d-sdk.js"
    },
    
    tools: ["hitokoto", "asteroids", "express", "switch-model", "switch-texture", "photo", "info", "quit"],
    
    drag: {
      enable: true,
      direction: ["x", "y"]
    },
    
    switchType: "order"
  }

  
  if (screen.width >= 768) {
    Promise.all([
      loadExternalResource(config.path.cssPath, "css"),
      loadExternalResource(config.path.live2dCorePath, "js"),
      loadExternalResource(config.path.live2dSdkPath, "js"),
      loadExternalResource(config.path.tipsJsPath, "js")
    ]).then(() => {
      initWidget({
        waifuPath: config.path.tipsJsonPath,
        cdnPath: config.path.modelPath,
        tools: config.tools,
        dragEnable: config.drag.enable,
        dragDirection: config.drag.direction,
        switchType: config.switchType
      });
    });
  }

  
  function loadExternalResource(url, type) {
    return new Promise((resolve, reject) => {
      let tag;
      if (type === "css") {
        tag = document.createElement("link");
        tag.rel = "stylesheet";
        tag.href = url;
      }
      else if (type === "js") {
        tag = document.createElement("script");
        tag.src = url;
      }
      if (tag) {
        tag.onload = () => resolve(url);
        tag.onerror = () => reject(url);
        document.head.appendChild(tag);
      }
    });
  }
</script>
<style>
    #TableOfContents > ul, ol {
        ul, ol {
            display: none;
        }
        .open {
            display: block;
        }
    }
</style>

<script>
    function initTocHide() {
        
        let toc = document.querySelector(".widget--toc");
        if (!toc) {
            return;
        }
        
        window.addEventListener('scroll', function() {
            
            let openUl = document.querySelectorAll(".open");
            if (openUl.length > 0) {
              openUl.forEach((ul) => {
                ul.classList.remove("open")
              })
            }
            
            let currentLi = document.querySelector(".active-class");
            if (!currentLi) {
                return
            }
            
            if (currentLi.children.length > 1) {
                currentLi.children[1].classList.add("open")
            }
            
            let ul = currentLi.parentElement;
            do {
                ul.classList.add("open");
                ul = ul.parentElement.parentElement
            } while (ul !== undefined && (ul.localName === 'ul' || ul.localName === 'ol'))
        });
    }
    initTocHide()
</script>
    </body>
</html>
